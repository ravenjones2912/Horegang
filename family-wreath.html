<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>‚ú®üíñ Family Wreath üíñ‚ú®</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
        }

        body {
            font-family: 'Comic Neue', cursive;
            overflow: hidden;
            background:
                radial-gradient(circle at 20% 50%, rgba(255, 105, 180, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 20, 147, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(255, 182, 193, 0.3) 0%, transparent 50%),
                linear-gradient(135deg, #ff1493 0%, #ff69b4 25%, #ffc0cb 50%, #ff69b4 75%, #ff1493 100%);
            background-size: 100% 100%, 100% 100%, 100% 100%, 400% 400%;
            animation: gradient 15s ease infinite;
            color: #fff;
        }
        
        @keyframes gradient {
            0% { background-position: 0% 50%, 0% 50%, 0% 50%, 0% 50%; }
            50% { background-position: 100% 50%, 100% 50%, 100% 50%, 100% 50%; }
            100% { background-position: 0% 50%, 0% 50%, 0% 50%, 0% 50%; }
        }
        
        /* Sparkle overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, hotpink 1px, transparent 1px),
                radial-gradient(circle, #ffd700 1px, transparent 1px);
            background-size: 50px 50px, 80px 80px, 100px 100px;
            background-position: 0 0, 40px 60px, 130px 270px;
            animation: sparkle 3s linear infinite;
            pointer-events: none;
            opacity: 0.6;
            z-index: 1;
        }
        
        @keyframes sparkle {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            position: relative;
            z-index: 2;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 200px;
            height: 100vh;
            background: linear-gradient(180deg, 
                rgba(255, 20, 147, 0.95) 0%,
                rgba(255, 105, 180, 0.95) 50%,
                rgba(255, 192, 203, 0.95) 100%);
            padding: 20px;
            box-shadow: 8px 0 30px rgba(255, 20, 147, 0.6);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .sidebar-title {
            color: white;
            font-size: 1.5em;
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: bounce 2s ease infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .sidebar button, .sidebar input {
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            border: 3px solid white;
            border-radius: 15px;
            padding: 12px;
            color: white;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            transition: all 0.3s ease;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            font-family: 'Comic Neue', cursive;
        }
        
        .sidebar button:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
            background: linear-gradient(135deg, #ffd700, #ff69b4);
        }
        
        .sidebar button.active {
            background: linear-gradient(135deg, #ffd700, #ff1493);
            border-color: #ffd700;
            transform: scale(1.05);
        }
        
        .sidebar input {
            text-align: left;
            font-weight: normal;
        }
        
        .sidebar input::placeholder {
            color: rgba(255, 255, 255, 0.8);
            font-weight: normal;
        }

        /* Canvas Container */
        #canvas-container {
            margin-left: 200px;
            flex: 1;
            position: relative;
            overflow: hidden;
            background: 
                radial-gradient(circle, rgba(255, 255, 255, 0.4) 2px, transparent 2px),
                radial-gradient(circle at 20% 30%, rgba(255, 192, 203, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 80% 50%, rgba(173, 216, 230, 0.4) 0%, transparent 40%),
                radial-gradient(circle at 40% 80%, rgba(255, 240, 180, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 70% 20%, rgba(230, 255, 230, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 50% 60%, rgba(230, 200, 255, 0.4) 0%, transparent 40%),
                linear-gradient(135deg, 
                    rgba(230, 200, 255, 0.7) 0%,
                    rgba(255, 230, 200, 0.7) 20%,
                    rgba(200, 255, 230, 0.7) 40%,
                    rgba(255, 220, 230, 0.7) 60%,
                    rgba(200, 230, 255, 0.7) 80%,
                    rgba(245, 230, 255, 0.7) 100%
                );
            background-size: 30px 30px, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            animation: containerSwirl 15s ease infinite;
            cursor: grab;
        }
        
        @keyframes containerSwirl {
            0%, 100% { 
                background-position: 0 0, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 50%;
            }
            50% { 
                background-position: 30px 30px, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 50%;
            }
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        #canvas-container.edit-mode {
            cursor: default;
        }

        #canvas {
            position: absolute;
            width: 10000px;
            height: 10000px;
            transform-origin: 0 0;
        }

        /* Sim Node */
        .sim-node {
            position: absolute;
            width: 180px;
            background: linear-gradient(135deg, 
                rgba(255, 192, 203, 0.9),
                rgba(255, 240, 245, 0.95));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            padding: 12px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: all 0.3s ease;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            user-select: none;
        }

        .sim-node:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 40px rgba(255, 20, 147, 0.6),
                inset 0 0 30px rgba(255, 255, 255, 0.4);
            border-image: linear-gradient(45deg, #ffd700, #ff1493, #ffd700) 1;
        }

        .sim-node.dragging {
            cursor: grabbing;
            box-shadow: 
                0 15px 50px rgba(255, 20, 147, 0.8),
                inset 0 0 40px rgba(255, 255, 255, 0.5);
            z-index: 1000;
        }

        .sim-node.highlighted {
            border-image: linear-gradient(45deg, #ffd700, #ff1493, #ffd700) 1;
            box-shadow: 
                0 0 40px rgba(255, 215, 0, 0.9),
                0 12px 40px rgba(255, 20, 147, 0.6),
                inset 0 0 30px rgba(255, 255, 255, 0.4);
            animation: pulse 1.5s ease-in-out 3;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        .sim-portrait {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            border: 3px solid white;
            box-shadow: 
                0 4px 15px rgba(255, 20, 147, 0.5),
                inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .sim-portrait.no-image {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sim-name {
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 4px;
            text-align: center;
            color: #ff1493;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .sim-lifestage {
            font-size: 12px;
            color: #8b008b;
            text-align: center;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .sim-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            margin-top: 6px;
        }

        .sim-tag {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: #fff;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(255, 20, 147, 0.4);
            border: 2px solid white;
        }

        .sim-tag.vampire { background: linear-gradient(135deg, #8b0000, #ff1493); }
        .sim-tag.spellcaster { background: linear-gradient(135deg, #9370db, #ff69b4); }
        .sim-tag.ghost { background: linear-gradient(135deg, #c0c0c0, #ffd700); }
        .sim-tag.mermaid { background: linear-gradient(135deg, #20b2aa, #ff69b4); }
        .sim-tag.alien { background: linear-gradient(135deg, #32cd32, #ffd700); }

        /* SVG Lines for relationships */
        #relationship-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .relationship-line {
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 4px rgba(255, 105, 180, 0.6));
        }

        .relationship-line.parent {
            stroke: #ff69b4;
            stroke-dasharray: none;
        }

        .relationship-line.partner {
            stroke: #ffd700;
            stroke-width: 4;
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8));
        }

        .relationship-line.adoptive {
            stroke: #ff1493;
            stroke-dasharray: 10, 5;
            filter: drop-shadow(0 0 4px rgba(255, 20, 147, 0.6));
        }

        /* Character Card Modal */
        #character-card-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 20, 147, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #character-card-modal.show {
            display: flex;
        }

        .character-card {
            background: linear-gradient(135deg, 
                rgba(255, 192, 203, 0.98),
                rgba(255, 240, 245, 0.98));
            border: 6px solid;
            border-image: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493) 1;
            border-radius: 20px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(255, 20, 147, 0.8),
                0 0 80px rgba(255, 105, 180, 0.6),
                inset 0 0 50px rgba(255, 192, 203, 0.3);
            position: relative;
        }

        .character-card h2 {
            background: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 3s ease infinite;
            margin-bottom: 16px;
            font-size: 24px;
            text-shadow: 
                2px 2px 0px rgba(255, 105, 180, 0.3),
                4px 4px 0px rgba(255, 182, 193, 0.2);
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
        }
        
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .character-card .close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            color: #fff;
            border: 3px solid white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            font-size: 20px;
            line-height: 1;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.5);
            font-weight: bold;
        }

        .character-card .close-btn:hover {
            background: linear-gradient(135deg, #ffd700, #ff1493);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.7);
        }

        .character-card-section {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700) 1;
            box-shadow: 
                0 4px 15px rgba(255, 105, 180, 0.3),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .character-card-section h3 {
            color: #ff1493;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .character-card-section p,
        .character-card-section ul {
            color: #8b008b;
            line-height: 1.6;
            font-weight: 600;
        }

        .character-card-section ul {
            list-style: none;
            padding: 0;
        }

        .character-card-section li {
            padding: 6px 0;
            border-bottom: 2px solid rgba(255, 105, 180, 0.2);
        }

        .character-card-section li:last-child {
            border-bottom: none;
        }

        .character-link {
            color: #ff1493;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            text-decoration: underline;
            transition: color 0.2s;
            font-weight: 700;
        }

        .character-link:hover {
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
        }

        /* Edit Modal */
        #edit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 20, 147, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #edit-modal.show {
            display: flex;
        }

        .edit-modal-content {
            background: linear-gradient(135deg, 
                rgba(255, 192, 203, 0.98),
                rgba(255, 240, 245, 0.98));
            border: 6px solid;
            border-image: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493) 1;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(255, 20, 147, 0.8),
                0 0 80px rgba(255, 105, 180, 0.6),
                inset 0 0 50px rgba(255, 192, 203, 0.3);
        }

        .edit-modal-content h2 {
            background: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 3s ease infinite;
            margin-bottom: 20px;
            font-size: 24px;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #ff1493;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700) 1;
            border-radius: 12px;
            color: #8b008b;
            font-size: 14px;
            font-family: 'Comic Neue', cursive;
            font-weight: 600;
            box-shadow: 
                0 4px 15px rgba(255, 105, 180, 0.2),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-image: linear-gradient(45deg, #ffd700, #ff1493) 1;
            box-shadow: 
                0 0 20px rgba(255, 215, 0, 0.5),
                inset 0 0 15px rgba(255, 255, 255, 0.6);
        }

        .form-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .form-buttons button {
            flex: 1;
            padding: 12px;
            border: 3px solid white;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 700;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: all 0.3s ease;
            font-family: 'Comic Neue', cursive;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.4);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            color: #fff;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #ffd700, #ff69b4);
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            color: #fff;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #8b0000, #ff1493);
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 0, 0, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #c0c0c0, #e0e0e0);
            color: #8b008b;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #e0e0e0, #c0c0c0);
            transform: scale(1.05) translateY(-2px);
        }

        .multi-select-container {
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700) 1;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
            box-shadow: inset 0 0 10px rgba(255, 192, 203, 0.3);
        }

        .multi-select-item {
            padding: 6px 10px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            border-radius: 8px;
            transition: background 0.2s;
            margin-bottom: 4px;
            color: #8b008b;
            font-weight: 600;
        }

        .multi-select-item:hover {
            background: rgba(255, 192, 203, 0.5);
        }

        .multi-select-item.selected {
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Context Menu */
        #context-menu {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.98), rgba(255, 240, 245, 0.98));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            z-index: 3000;
            min-width: 180px;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: background 0.2s;
            border-bottom: 2px solid rgba(255, 105, 180, 0.3);
            color: #ff1493;
            font-weight: 700;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: rgba(255, 215, 0, 0.4);
        }

        /* Zoom Controls */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        #zoom-controls button {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            border: 3px solid white;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: 700;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.5);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #zoom-controls button:hover {
            background: linear-gradient(135deg, #ffd700, #ff1493);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.7);
        }

        .zoom-level {
            text-align: center;
            font-size: 14px;
            color: #ff1493;
            margin: 4px 0;
            font-weight: 700;
            text-shadow: 
                1px 1px 2px rgba(255, 255, 255, 0.8),
                0 0 10px rgba(255, 215, 0, 0.6);
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .sidebar {
                width: 160px;
                padding: 12px;
            }

            .sidebar button {
                padding: 10px;
                font-size: 0.9em;
            }

            #canvas-container {
                margin-left: 160px;
            }

            .sim-node {
                width: 150px;
            }

            .character-card {
                width: 95%;
                max-height: 85vh;
                padding: 16px;
            }
            
            .family-wreath-title {
                font-size: 2.5em !important;
                top: 15px !important;
            }
            
            .family-wreath-subtitle {
                font-size: 1.1em !important;
                top: 70px !important;
            }
            
            .search-bar-container {
                top: 110px !important;
            }
            
            .search-bar-container #search-input {
                width: 280px !important;
                font-size: 14px !important;
                padding: 10px 16px !important;
            }
            
            .search-bar-container #search-results {
                width: 280px !important;
            }
        }
        
        /* Family Wreath Title */
        .family-wreath-title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
            background: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3.5em;
            margin: 0 0 5px 0;
            text-shadow: 
                3px 3px 0px rgba(255, 105, 180, 0.5),
                6px 6px 0px rgba(255, 182, 193, 0.3);
            animation: rainbowText 3s ease infinite;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
            letter-spacing: 3px;
            pointer-events: none;
        }
        
        .family-wreath-subtitle {
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
            color: #ff1493;
            font-size: 1.4em;
            margin: 0;
            font-weight: bold;
            text-shadow: 
                2px 2px 0px #ffc0cb,
                -1px -1px 0px #ff69b4;
            animation: bounce 2s ease infinite;
            pointer-events: none;
        }
        
        /* Search Bar Container */
        .search-bar-container {
            position: fixed;
            top: 135px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
        }
        
        .search-bar-container #search-input {
            padding: 12px 20px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.95);
            color: #8b008b;
            font-size: 16px;
            width: 350px;
            font-family: 'Comic Neue', cursive;
            font-weight: 600;
            box-shadow: 
                0 4px 15px rgba(255, 105, 180, 0.4),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .search-bar-container #search-input:focus {
            outline: none;
            border-image: linear-gradient(45deg, #ffd700, #ff1493, #ffd700) 1;
            box-shadow: 
                0 0 25px rgba(255, 215, 0, 0.6),
                inset 0 0 15px rgba(255, 255, 255, 0.6);
            transform: scale(1.02);
        }
        
        .search-bar-container #search-input::placeholder {
            color: rgba(139, 0, 139, 0.6);
        }
        
        .search-bar-container #search-results {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.98), rgba(255, 240, 245, 0.98));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            width: 350px;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        .search-result-item {
            padding: 10px 14px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            border-bottom: 2px solid rgba(255, 105, 180, 0.3);
            transition: background 0.2s;
            color: #ff1493;
            font-weight: bold;
        }

        .search-result-item:hover {
            background: rgba(255, 215, 0, 0.3);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }
        
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 120px;
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.95), rgba(255, 240, 245, 0.95));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            z-index: 100;
            overflow: hidden;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .minimap-viewport {
            position: absolute;
            border: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.2);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        /* Floating hearts animation */
        @keyframes floatUp {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .heart {
            position: fixed;
            bottom: -50px;
            font-size: 30px;
            animation: floatUp 10s linear forwards;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Sidebar Navigation -->
        <div class="sidebar">
            <div class="sidebar-title">üíñ MENU üíñ</div>
            
            <div id="statusIndicator" style="padding: 10px; margin: 10px 0; border-radius: 10px; font-size: 0.9em; text-align: center; font-weight: bold;"></div>
            
            <button id="publishBtn" onclick="downloadFamilyWreathJSON()" style="
                display: none;
                background: linear-gradient(135deg, #32cd32, #228b22);
                border: 3px solid white;
                border-radius: 12px;
                padding: 12px;
                color: white;
                font-size: 1em;
                font-weight: bold;
                font-family: 'Comic Neue', cursive;
                cursor: pointer;
                width: 100%;
                margin-bottom: 10px;
                box-shadow: 0 4px 15px rgba(50, 205, 50, 0.6);
                transition: all 0.3s ease;
            ">üì• Download family-wreath.json</button>
            <div id="publishHint" style="display: none; margin-bottom: 10px; color: #006400; font-size: 0.8em; text-align: center;">
                Download, then upload to <a href="https://github.com/ravenjones2912/HoregangData" target="_blank" style="color: #228b22; font-weight: bold;">HoregangData repo</a>
            </div>
            
            <button onclick="window.location.href='home.html'">üè† Home</button>
            <button id="addSimBtn" onclick="addNewSim()">‚ûï Add a Sim</button>
            <button id="edit-mode-btn" onclick="toggleEditMode()">‚úèÔ∏è Edit Mode</button>
            <button onclick="resetView()">üîÑ Reset View</button>
            <button onclick="fitToScreen()">üìê Fit All</button>
            <button id="saveLoadBtn" onclick="showExportImport()">üíæ Save/Load</button>
            <button onclick="logout()" style="margin-top: auto;">üîí Logout</button>
        </div>

        <!-- Canvas Container -->
        <div id="canvas-container">
            <h1 class="family-wreath-title">Family Wreath</h1>
            <div class="family-wreath-subtitle">üó°Ô∏èCo-Produced by the ghost of VC Andrewsüó°Ô∏è</div>
            <div class="search-bar-container">
                <input type="text" id="search-input" placeholder="üîç Search Sim by name..." oninput="handleSearch()">
                <div id="search-results"></div>
            </div>
            <div id="canvas">
                <svg id="relationship-svg"></svg>
            </div>

            <!-- Zoom Controls -->
            <div id="zoom-controls">
                <button onclick="zoomIn()">+</button>
                <div class="zoom-level" id="zoom-level">100%</div>
                <button onclick="zoomOut()">‚àí</button>
            </div>

            <!-- Minimap -->
            <div id="minimap">
                <canvas id="minimap-canvas"></canvas>
                <div class="minimap-viewport" id="minimap-viewport"></div>
            </div>
        </div>
    </div>

    <!-- Character Card Modal -->
    <div id="character-card-modal" onclick="closeCharacterCard(event)">
        <div class="character-card" onclick="event.stopPropagation()">
            <button class="close-btn" onclick="closeCharacterCard()">√ó</button>
            <div id="character-card-content"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" onclick="closeEditModal(event)">
        <div class="edit-modal-content" onclick="event.stopPropagation()">
            <h2 id="edit-modal-title">Add Sim</h2>
            <div class="form-group">
                <label>Name *</label>
                <input type="text" id="edit-name" required>
            </div>
            <div class="form-group">
                <label>Portrait</label>
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                    <button type="button" class="btn-secondary" style="flex: 0 0 auto; padding: 8px 12px;" onclick="document.getElementById('portrait-upload').click()">üì∑ Upload Image</button>
                    <input type="file" id="portrait-upload" accept="image/*" style="display: none;" onchange="handlePortraitUpload(event)">
                    <span id="portrait-filename" style="font-size: 12px; color: #8b008b; font-weight: 600;"></span>
                </div>
                <input type="text" id="edit-portrait" placeholder="Or enter an emoji (e.g., üë®)">
                <div id="portrait-preview" style="margin-top: 10px; text-align: center;"></div>
            </div>
            <div class="form-group">
                <label>Lifestage</label>
                <select id="edit-lifestage">
                    <option value="Baby">Baby</option>
                    <option value="Toddler">Toddler</option>
                    <option value="Child">Child</option>
                    <option value="Teen">Teen</option>
                    <option value="Young Adult">Young Adult</option>
                    <option value="Adult" selected>Adult</option>
                    <option value="Elder">Elder</option>
                </select>
            </div>
            <div class="form-group">
                <label>Tags (comma-separated: vampire, spellcaster, ghost, mermaid, alien)</label>
                <input type="text" id="edit-tags" placeholder="e.g., vampire, spellcaster">
            </div>
            <div class="form-group">
                <label>Traits (comma-separated)</label>
                <input type="text" id="edit-traits" placeholder="e.g., Ambitious, Creative, Hot-headed">
            </div>
            <div class="form-group">
                <label>Bio/Notes</label>
                <textarea id="edit-bio"></textarea>
            </div>
            <div class="form-group">
                <label>Life Events (one per line)</label>
                <textarea id="edit-events" placeholder="e.g., Moved to Willow Creek&#10;Opened a bakery"></textarea>
            </div>
            <div class="form-group">
                <label>Parents (select multiple)</label>
                <div class="multi-select-container" id="edit-parents"></div>
            </div>
            <div class="form-group">
                <label>Partners/Spouses (select multiple)</label>
                <div class="multi-select-container" id="edit-partners"></div>
            </div>
            <div class="form-buttons">
                <button class="btn-primary" onclick="saveEditedSim()">Save</button>
                <button class="btn-danger" id="delete-sim-btn" onclick="deleteCurrentSim()" style="display:none;">Delete</button>
                <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-item" onclick="addSimFromContext()">Add Sim Here</div>
        <div class="context-menu-item" onclick="addRelationship()">Add Relationship</div>
    </div>

    <script>
        // ============================================
        // LOGIN PROTECTION
        // ============================================
        if (sessionStorage.getItem('dynastyLoggedIn') !== 'true') {
            window.location.href = 'index.html';
        }
        
        // ============================================
        // GITHUB CONFIGURATION (NO TOKEN NEEDED)
        // ============================================
        const GITHUB_OWNER = 'ravenjones2912';
        const DATA_REPO = 'HoregangData';
        const BRANCH = 'main';
        const FAMILY_FILE = 'family-wreath.json';
        const isAdmin = sessionStorage.getItem('dynastyUser') === 'admin';
        
        console.log('Current user:', sessionStorage.getItem('dynastyUser'));
        console.log('Is admin?', isAdmin);
        
        // ============================================
        // LOGOUT FUNCTION
        // ============================================
        function logout() {
            sessionStorage.removeItem('dynastyLoggedIn');
            sessionStorage.removeItem('dynastyUser');
            window.location.href = 'index.html';
        }
        
        // ============================================
        // DATA MODEL
        // ============================================
        let familyData = {
            people: [],
            relationships: [],
            layout: {
                positions: {}
            }
        };

        // ============================================
        // STATE
        // ============================================
        let state = {
            scale: 1,
            translateX: 0,
            translateY: 0,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            draggedNode: null,
            editMode: false,
            currentEditingId: null,
            contextMenuPos: { x: 0, y: 0 }
        };

        const MIN_SCALE = 0.3;
        const MAX_SCALE = 2.5;
        const ZOOM_SPEED = 0.1;

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            // Initialize based on mode
            if (isAdmin) {
                document.getElementById('statusIndicator').innerHTML = 'üëë ADMIN MODE';
                document.getElementById('statusIndicator').style.cssText = 'background: rgba(255, 215, 0, 0.3); border: 2px solid #ffd700; color: #ff1493;';
                document.getElementById('publishBtn').style.display = 'block';
                document.getElementById('publishHint').style.display = 'block';
                loadFromStorage(); // Load admin's local edits
            } else {
                document.getElementById('statusIndicator').innerHTML = 'üëÄ VISITOR MODE';
                document.getElementById('statusIndicator').style.cssText = 'background: rgba(144, 238, 144, 0.3); border: 2px solid #90ee90; color: #006400;';
                // Hide admin-only buttons for visitors
                document.getElementById('addSimBtn').style.display = 'none';
                document.getElementById('edit-mode-btn').style.display = 'none';
                document.getElementById('saveLoadBtn').style.display = 'none';
                
                // Load from GitHub for visitors
                const loaded = await loadFamilyFromGitHub();
                if (!loaded) {
                    // If no published version, load defaults
                    loadFromStorage();
                }
            }
            
            setupEventListeners();
            centerView();
            render();
        }

        function setupEventListeners() {
            const container = document.getElementById('canvas-container');
            
            // Pan
            container.addEventListener('mousedown', handleMouseDown);
            container.addEventListener('mousemove', handleMouseMove);
            container.addEventListener('mouseup', handleMouseUp);
            container.addEventListener('mouseleave', handleMouseUp);

            // Zoom
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Touch events
            container.addEventListener('touchstart', handleTouchStart, { passive: false });
            container.addEventListener('touchmove', handleTouchMove, { passive: false });
            container.addEventListener('touchend', handleTouchEnd);

            // Context menu
            container.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', () => {
                document.getElementById('context-menu').style.display = 'none';
            });

            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#search-input') && !e.target.closest('#search-results')) {
                    document.getElementById('search-results').style.display = 'none';
                }
            });
        }

        // ============================================
        // PORTRAIT UPLOAD
        // ============================================
        let uploadedPortraitData = null;
        
        function handlePortraitUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedPortraitData = e.target.result;
                document.getElementById('portrait-filename').textContent = file.name;
                document.getElementById('edit-portrait').value = ''; // Clear emoji field
                
                // Show preview
                const preview = document.getElementById('portrait-preview');
                preview.innerHTML = `<img src="${uploadedPortraitData}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid #ff69b4; box-shadow: 0 4px 15px rgba(255, 105, 180, 0.5);">`;
            };
            reader.readAsDataURL(file);
        }
        
        // ============================================
        // RENDERING
        // ============================================
        function render() {
            renderNodes();
            renderRelationships();
            updateTransform();
            updateMinimap();
        }

        function renderNodes() {
            const canvas = document.getElementById('canvas');
            // Remove existing nodes
            const existingNodes = canvas.querySelectorAll('.sim-node');
            existingNodes.forEach(node => node.remove());

            familyData.people.forEach(person => {
                const pos = familyData.layout.positions[person.id] || { x: 0, y: 0 };
                const node = createNodeElement(person, pos);
                canvas.appendChild(node);
            });
        }

        function createNodeElement(person, pos) {
            const node = document.createElement('div');
            node.className = 'sim-node';
            node.id = `node-${person.id}`;
            node.style.left = `${pos.x}px`;
            node.style.top = `${pos.y}px`;
            node.dataset.personId = person.id;

            // Portrait
            const portrait = document.createElement('div');
            portrait.className = 'sim-portrait';
            if (person.portrait) {
                if (person.portrait.startsWith('data:image/')) {
                    // It's an uploaded image
                    portrait.style.backgroundImage = `url(${person.portrait})`;
                    portrait.style.backgroundSize = 'cover';
                    portrait.style.backgroundPosition = 'center';
                } else {
                    // It's an emoji
                    portrait.textContent = person.portrait;
                }
            } else {
                portrait.className += ' no-image';
                portrait.textContent = person.name.split(' ').map(n => n[0]).join('');
            }

            // Name
            const name = document.createElement('div');
            name.className = 'sim-name';
            name.textContent = person.name;

            // Lifestage
            const lifestage = document.createElement('div');
            lifestage.className = 'sim-lifestage';
            lifestage.textContent = person.lifestage || '';

            // Tags
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'sim-tags';
            person.tags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = `sim-tag ${tag.toLowerCase()}`;
                tagEl.textContent = tag;
                tagsContainer.appendChild(tagEl);
            });

            node.appendChild(portrait);
            node.appendChild(name);
            node.appendChild(lifestage);
            node.appendChild(tagsContainer);

            // Event handlers
            node.addEventListener('click', (e) => {
                if (!state.editMode) {
                    e.stopPropagation();
                    showCharacterCard(person.id);
                }
            });

            if (state.editMode) {
                node.addEventListener('mousedown', (e) => startDragNode(e, person.id));
                node.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    editSim(person.id);
                });
            }

            return node;
        }

        function renderRelationships() {
            const svg = document.getElementById('relationship-svg');
            svg.innerHTML = '';
            svg.setAttribute('width', '10000');
            svg.setAttribute('height', '10000');

            const drawnLines = new Set();

            // Draw parent-child relationships
            familyData.relationships.forEach(rel => {
                if (rel.type === 'parent') {
                    const parent = familyData.people.find(p => p.id === rel.from);
                    const child = familyData.people.find(p => p.id === rel.to);
                    if (!parent || !child) return;

                    const lineId = `${rel.from}-${rel.to}`;
                    if (drawnLines.has(lineId)) return;
                    drawnLines.add(lineId);

                    const parentPos = familyData.layout.positions[rel.from];
                    const childPos = familyData.layout.positions[rel.to];
                    
                    // Connect from bottom edge of parent to top edge of child
                    const x1 = parentPos.x + 90;
                    const y1 = parentPos.y + 130; // Bottom edge of parent card
                    const x2 = childPos.x + 90;
                    const y2 = childPos.y; // Top edge of child card

                    const midY = (y1 + y2) / 2;

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`);
                    path.classList.add('relationship-line', 'parent');
                    if (rel.kind === 'adoptive') {
                        path.classList.add('adoptive');
                    }
                    svg.appendChild(path);
                }
            });

            // Draw partner relationships
            const partnerPairs = new Set();
            familyData.relationships.forEach(rel => {
                if (rel.type === 'partner') {
                    const p1 = familyData.people.find(p => p.id === rel.from);
                    const p2 = familyData.people.find(p => p.id === rel.to);
                    if (!p1 || !p2) return;

                    const pairId = [rel.from, rel.to].sort().join('-');
                    if (partnerPairs.has(pairId)) return;
                    partnerPairs.add(pairId);

                    const pos1 = familyData.layout.positions[rel.from];
                    const pos2 = familyData.layout.positions[rel.to];

                    // Determine which node is on the left
                    const leftPos = pos1.x < pos2.x ? pos1 : pos2;
                    const rightPos = pos1.x < pos2.x ? pos2 : pos1;

                    // Connect right edge of left card to left edge of right card
                    const x1 = leftPos.x + 180; // Right edge of left card
                    const y1 = leftPos.y + 65; // Middle height
                    const x2 = rightPos.x; // Left edge of right card
                    const y2 = rightPos.y + 65; // Middle height

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.classList.add('relationship-line', 'partner');
                    svg.appendChild(line);
                }
            });
        }

        function updateTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
            document.getElementById('zoom-level').textContent = `${Math.round(state.scale * 100)}%`;
        }

        // ============================================
        // PAN & ZOOM
        // ============================================
        function handleMouseDown(e) {
            if (e.target.id === 'canvas-container' || e.target.id === 'canvas' || e.target.id === 'relationship-svg') {
                state.isDragging = true;
                state.dragStartX = e.clientX - state.translateX;
                state.dragStartY = e.clientY - state.translateY;
                document.getElementById('canvas-container').classList.add('dragging');
            }
        }

        function handleMouseMove(e) {
            if (state.isDragging && !state.draggedNode) {
                state.translateX = e.clientX - state.dragStartX;
                state.translateY = e.clientY - state.dragStartY;
                updateTransform();
            } else if (state.draggedNode) {
                const rect = document.getElementById('canvas').getBoundingClientRect();
                const x = (e.clientX - rect.left) / state.scale;
                const y = (e.clientY - rect.top) / state.scale;
                
                familyData.layout.positions[state.draggedNode] = { 
                    x: x - 90, 
                    y: y - 65 
                };
                render();
            }
        }

        function handleMouseUp() {
            state.isDragging = false;
            document.getElementById('canvas-container').classList.remove('dragging');
            
            if (state.draggedNode) {
                saveToStorage();
                state.draggedNode = null;
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Get mouse position relative to container
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate position in canvas before zoom
            const canvasX = (mouseX - state.translateX) / state.scale;
            const canvasY = (mouseY - state.translateY) / state.scale;
            
            // Update scale
            const delta = -Math.sign(e.deltaY) * ZOOM_SPEED;
            const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, state.scale + delta));
            
            // Calculate new translation to keep mouse position fixed
            state.translateX = mouseX - canvasX * newScale;
            state.translateY = mouseY - canvasY * newScale;
            state.scale = newScale;
            
            updateTransform();
        }

        function zoomIn() {
            const newScale = Math.min(MAX_SCALE, state.scale + ZOOM_SPEED);
            zoomToCenter(newScale);
        }

        function zoomOut() {
            const newScale = Math.max(MIN_SCALE, state.scale - ZOOM_SPEED);
            zoomToCenter(newScale);
        }

        function zoomToCenter(newScale) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const canvasX = (centerX - state.translateX) / state.scale;
            const canvasY = (centerY - state.translateY) / state.scale;
            
            state.translateX = centerX - canvasX * newScale;
            state.translateY = centerY - canvasY * newScale;
            state.scale = newScale;
            
            updateTransform();
        }

        function resetView() {
            state.scale = 1;
            centerView();
        }

        function centerView() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Find bounds of all nodes
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            Object.values(familyData.layout.positions).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + 180);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + 150);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Account for the search bar and title at the top (about 200px)
            const effectiveHeight = rect.height - 200;
            const effectiveCenterY = rect.height / 2 + 100;
            
            state.translateX = rect.width / 2 - centerX * state.scale;
            state.translateY = effectiveCenterY - centerY * state.scale;
            
            updateTransform();
        }

        function fitToScreen() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            Object.values(familyData.layout.positions).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + 180);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + 150);
            });
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            // Account for search bar and title
            const effectiveHeight = rect.height - 250;
            
            const scaleX = (rect.width - 100) / width;
            const scaleY = (effectiveHeight - 100) / height;
            state.scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, Math.min(scaleX, scaleY)));
            
            centerView();
        }

        // ============================================
        // TOUCH EVENTS
        // ============================================
        let touchStartDist = 0;
        let touchStartScale = 1;

        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartDist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                touchStartScale = state.scale;
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                state.isDragging = true;
                state.dragStartX = touch.clientX - state.translateX;
                state.dragStartY = touch.clientY - state.translateY;
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, 
                    touchStartScale * (dist / touchStartDist)));
                state.scale = newScale;
                updateTransform();
            } else if (e.touches.length === 1 && state.isDragging) {
                const touch = e.touches[0];
                state.translateX = touch.clientX - state.dragStartX;
                state.translateY = touch.clientY - state.dragStartY;
                updateTransform();
            }
        }

        function handleTouchEnd() {
            state.isDragging = false;
            touchStartDist = 0;
        }

        // ============================================
        // NODE DRAGGING (Edit Mode)
        // ============================================
        function startDragNode(e, personId) {
            if (!state.editMode) return;
            e.stopPropagation();
            state.draggedNode = personId;
            const node = document.getElementById(`node-${personId}`);
            node.classList.add('dragging');
        }

        // ============================================
        // CHARACTER CARD
        // ============================================
        function showCharacterCard(personId) {
            const person = familyData.people.find(p => p.id === personId);
            if (!person) return;

            const content = document.getElementById('character-card-content');
            let html = `<h2>${person.name}</h2>`;

            // Lifestage & Tags
            if (person.lifestage) {
                html += `<div class="character-card-section">
                    <h3>Lifestage</h3>
                    <p>${person.lifestage}</p>
                </div>`;
            }

            if (person.tags && person.tags.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Occult Type</h3>
                    <p>${person.tags.join(', ')}</p>
                </div>`;
            }

            // Bio
            if (person.bio) {
                html += `<div class="character-card-section">
                    <h3>Bio</h3>
                    <p>${person.bio}</p>
                </div>`;
            }

            // Traits
            if (person.traits && person.traits.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Traits</h3>
                    <p>${person.traits.join(', ')}</p>
                </div>`;
            }

            // Life Events
            if (person.events && person.events.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Life Events</h3>
                    <ul>`;
                person.events.forEach(event => {
                    html += `<li>${event}</li>`;
                });
                html += `</ul></div>`;
            }

            // Relationships
            const partners = familyData.relationships
                .filter(r => r.type === 'partner' && (r.from === personId || r.to === personId))
                .map(r => {
                    const partnerId = r.from === personId ? r.to : r.from;
                    const partner = familyData.people.find(p => p.id === partnerId);
                    return partner ? `<span class="character-link" onclick="centerOnSim('${partnerId}')">${partner.name}</span> (${r.status})` : '';
                })
                .filter(p => p);

            if (partners.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Partners</h3>
                    <p>${partners.join('<br>')}</p>
                </div>`;
            }

            const parents = familyData.relationships
                .filter(r => r.type === 'parent' && r.to === personId)
                .map(r => {
                    const parent = familyData.people.find(p => p.id === r.from);
                    return parent ? `<span class="character-link" onclick="centerOnSim('${r.from}')">${parent.name}</span>` : '';
                })
                .filter(p => p);

            if (parents.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Parents</h3>
                    <p>${parents.join(', ')}</p>
                </div>`;
            }

            const children = familyData.relationships
                .filter(r => r.type === 'parent' && r.from === personId)
                .map(r => {
                    const child = familyData.people.find(p => p.id === r.to);
                    return child ? `<span class="character-link" onclick="centerOnSim('${r.to}')">${child.name}</span>` : '';
                })
                .filter(c => c);

            if (children.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Children</h3>
                    <p>${children.join(', ')}</p>
                </div>`;
            }

            content.innerHTML = html;
            document.getElementById('character-card-modal').classList.add('show');
        }

        function closeCharacterCard(event) {
            if (!event || event.target.id === 'character-card-modal') {
                document.getElementById('character-card-modal').classList.remove('show');
            }
        }

        function centerOnSim(personId) {
            const pos = familyData.layout.positions[personId];
            if (!pos) return;

            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            state.translateX = rect.width / 2 - (pos.x + 90) * state.scale;
            state.translateY = rect.height / 2 - (pos.y + 65) * state.scale;
            updateTransform();

            // Highlight the node
            const node = document.getElementById(`node-${personId}`);
            if (node) {
                node.classList.add('highlighted');
                setTimeout(() => node.classList.remove('highlighted'), 3000);
            }

            closeCharacterCard();
        }

        // ============================================
        // SEARCH
        // ============================================
        function handleSearch() {
            const query = document.getElementById('search-input').value.toLowerCase().trim();
            const resultsDiv = document.getElementById('search-results');

            if (!query) {
                resultsDiv.style.display = 'none';
                return;
            }

            const matches = familyData.people.filter(p => 
                p.name.toLowerCase().includes(query)
            );

            if (matches.length === 0) {
                resultsDiv.innerHTML = '<div class="search-result-item">No results found</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            resultsDiv.innerHTML = matches.map(person => 
                `<div class="search-result-item" onclick="searchResultClick('${person.id}')">
                    ${person.name} (${person.lifestage || 'Unknown'})
                </div>`
            ).join('');
            resultsDiv.style.display = 'block';
        }

        function searchResultClick(personId) {
            centerOnSim(personId);
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').style.display = 'none';
        }

        // ============================================
        // EDIT MODE
        // ============================================
        function addNewSim() {
            if (!isAdmin) {
                alert('Only admins can add new Sims!');
                return;
            }
            state.currentEditingId = null;
            // Position new Sim in center of current view
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const centerX = (rect.width / 2 - state.translateX) / state.scale;
            const centerY = (rect.height / 2 - state.translateY) / state.scale;
            state.contextMenuPos = { x: centerX, y: centerY };
            openEditModal();
        }
        
        function toggleEditMode() {
            if (!isAdmin) {
                alert('Only admins can edit!');
                return;
            }
            state.editMode = !state.editMode;
            const btn = document.getElementById('edit-mode-btn');
            const container = document.getElementById('canvas-container');
            
            if (state.editMode) {
                btn.classList.add('active');
                btn.textContent = '‚úèÔ∏è Edit Mode (ON)';
                container.classList.add('edit-mode');
            } else {
                btn.classList.remove('active');
                btn.textContent = '‚úèÔ∏è Edit Mode';
                container.classList.remove('edit-mode');
            }
            
            render();
        }

        function handleContextMenu(e) {
            if (!state.editMode) return;
            e.preventDefault();
            
            const menu = document.getElementById('context-menu');
            const rect = document.getElementById('canvas').getBoundingClientRect();
            
            state.contextMenuPos.x = (e.clientX - rect.left) / state.scale;
            state.contextMenuPos.y = (e.clientY - rect.top) / state.scale;
            
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            menu.style.display = 'block';
        }

        function addSimFromContext() {
            document.getElementById('context-menu').style.display = 'none';
            state.currentEditingId = null;
            openEditModal();
        }

        function addRelationship() {
            document.getElementById('context-menu').style.display = 'none';
            alert('To add a relationship: Edit a Sim and select their partners or parents in the form.');
        }

        // ============================================
        // EDIT MODAL
        // ============================================
        function openEditModal() {
            uploadedPortraitData = null; // Reset upload data
            document.getElementById('portrait-filename').textContent = '';
            document.getElementById('portrait-preview').innerHTML = '';
            document.getElementById('edit-modal').classList.add('show');
            populateRelationshipSelectors();
            
            if (state.currentEditingId) {
                // Edit existing
                const person = familyData.people.find(p => p.id === state.currentEditingId);
                document.getElementById('edit-modal-title').textContent = 'Edit Sim';
                document.getElementById('edit-name').value = person.name;
                
                // Handle portrait
                if (person.portrait) {
                    if (person.portrait.startsWith('data:image/')) {
                        // It's an uploaded image
                        uploadedPortraitData = person.portrait;
                        document.getElementById('portrait-filename').textContent = 'Current image';
                        document.getElementById('portrait-preview').innerHTML = `<img src="${person.portrait}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid #ff69b4; box-shadow: 0 4px 15px rgba(255, 105, 180, 0.5);">`;
                        document.getElementById('edit-portrait').value = '';
                    } else {
                        // It's an emoji
                        document.getElementById('edit-portrait').value = person.portrait;
                    }
                } else {
                    document.getElementById('edit-portrait').value = '';
                }
                
                document.getElementById('edit-lifestage').value = person.lifestage;
                document.getElementById('edit-tags').value = person.tags.join(', ');
                document.getElementById('edit-traits').value = person.traits.join(', ');
                document.getElementById('edit-bio').value = person.bio || '';
                document.getElementById('edit-events').value = person.events.join('\n');
                
                // Select parents
                const parentRels = familyData.relationships.filter(r => 
                    r.type === 'parent' && r.to === state.currentEditingId
                );
                parentRels.forEach(rel => {
                    const item = document.querySelector(`#edit-parents [data-person-id="${rel.from}"]`);
                    if (item) item.classList.add('selected');
                });
                
                // Select partners
                const partnerRels = familyData.relationships.filter(r => 
                    r.type === 'partner' && (r.from === state.currentEditingId || r.to === state.currentEditingId)
                );
                partnerRels.forEach(rel => {
                    const partnerId = rel.from === state.currentEditingId ? rel.to : rel.from;
                    const item = document.querySelector(`#edit-partners [data-person-id="${partnerId}"]`);
                    if (item) item.classList.add('selected');
                });
                
                document.getElementById('delete-sim-btn').style.display = 'block';
            } else {
                // Add new
                document.getElementById('edit-modal-title').textContent = 'Add Sim';
                document.getElementById('edit-name').value = '';
                document.getElementById('edit-portrait').value = '';
                document.getElementById('edit-lifestage').value = 'Adult';
                document.getElementById('edit-tags').value = '';
                document.getElementById('edit-traits').value = '';
                document.getElementById('edit-bio').value = '';
                document.getElementById('edit-events').value = '';
                document.getElementById('delete-sim-btn').style.display = 'none';
            }
        }

        function populateRelationshipSelectors() {
            const parentsDiv = document.getElementById('edit-parents');
            const partnersDiv = document.getElementById('edit-partners');
            
            parentsDiv.innerHTML = '';
            partnersDiv.innerHTML = '';
            
            familyData.people.forEach(person => {
                if (person.id === state.currentEditingId) return;
                
                const parentItem = document.createElement('div');
                parentItem.className = 'multi-select-item';
                parentItem.textContent = person.name;
                parentItem.dataset.personId = person.id;
                parentItem.onclick = function() {
                    this.classList.toggle('selected');
                };
                parentsDiv.appendChild(parentItem);
                
                const partnerItem = document.createElement('div');
                partnerItem.className = 'multi-select-item';
                partnerItem.textContent = person.name;
                partnerItem.dataset.personId = person.id;
                partnerItem.onclick = function() {
                    this.classList.toggle('selected');
                };
                partnersDiv.appendChild(partnerItem);
            });
        }

        function editSim(personId) {
            if (!isAdmin) {
                alert('Only admins can edit Sims!');
                return;
            }
            state.currentEditingId = personId;
            openEditModal();
        }

        function saveEditedSim() {
            const name = document.getElementById('edit-name').value.trim();
            if (!name) {
                alert('Please enter a name!');
                return;
            }

            // Use uploaded image if available, otherwise use emoji field
            const portrait = uploadedPortraitData || document.getElementById('edit-portrait').value.trim() || null;
            const lifestage = document.getElementById('edit-lifestage').value;
            const tags = document.getElementById('edit-tags').value.split(',').map(t => t.trim()).filter(t => t);
            const traits = document.getElementById('edit-traits').value.split(',').map(t => t.trim()).filter(t => t);
            const bio = document.getElementById('edit-bio').value.trim();
            const events = document.getElementById('edit-events').value.split('\n').map(e => e.trim()).filter(e => e);

            const selectedParents = Array.from(document.querySelectorAll('#edit-parents .selected'))
                .map(el => el.dataset.personId);
            const selectedPartners = Array.from(document.querySelectorAll('#edit-partners .selected'))
                .map(el => el.dataset.personId);

            if (state.currentEditingId) {
                // Update existing
                const person = familyData.people.find(p => p.id === state.currentEditingId);
                person.name = name;
                person.portrait = portrait;
                person.lifestage = lifestage;
                person.tags = tags;
                person.traits = traits;
                person.bio = bio;
                person.events = events;

                // Update relationships
                // Remove old parent relationships
                familyData.relationships = familyData.relationships.filter(r => 
                    !(r.type === 'parent' && r.to === state.currentEditingId)
                );
                // Add new parent relationships
                selectedParents.forEach(parentId => {
                    familyData.relationships.push({
                        type: 'parent',
                        from: parentId,
                        to: state.currentEditingId,
                        kind: 'biological'
                    });
                });

                // Remove old partner relationships
                familyData.relationships = familyData.relationships.filter(r => 
                    !(r.type === 'partner' && (r.from === state.currentEditingId || r.to === state.currentEditingId))
                );
                // Add new partner relationships
                selectedPartners.forEach(partnerId => {
                    familyData.relationships.push({
                        type: 'partner',
                        from: state.currentEditingId,
                        to: partnerId,
                        status: 'dating'
                    });
                });
            } else {
                // Add new
                const newId = 'p' + Date.now();
                familyData.people.push({
                    id: newId,
                    name,
                    portrait,
                    lifestage,
                    tags,
                    traits,
                    bio,
                    events
                });

                // Set position (use context menu position or default)
                familyData.layout.positions[newId] = {
                    x: state.contextMenuPos.x - 90 || 0,
                    y: state.contextMenuPos.y - 65 || 0
                };

                // Add relationships
                selectedParents.forEach(parentId => {
                    familyData.relationships.push({
                        type: 'parent',
                        from: parentId,
                        to: newId,
                        kind: 'biological'
                    });
                });

                selectedPartners.forEach(partnerId => {
                    familyData.relationships.push({
                        type: 'partner',
                        from: newId,
                        to: partnerId,
                        status: 'dating'
                    });
                });
            }

            saveToStorage();
            render();
            closeEditModal();
        }

        function deleteCurrentSim() {
            if (!confirm('Are you sure you want to delete this Sim? This cannot be undone.')) {
                return;
            }

            familyData.people = familyData.people.filter(p => p.id !== state.currentEditingId);
            familyData.relationships = familyData.relationships.filter(r => 
                r.from !== state.currentEditingId && r.to !== state.currentEditingId
            );
            delete familyData.layout.positions[state.currentEditingId];

            saveToStorage();
            render();
            closeEditModal();
        }

        function closeEditModal(event) {
            if (!event || event.target.id === 'edit-modal') {
                document.getElementById('edit-modal').classList.remove('show');
                state.currentEditingId = null;
            }
        }

        // ============================================
        // SAVE/LOAD
        // ============================================
        function saveToStorage() {
            if (isAdmin) {
                localStorage.setItem('familywreathData', JSON.stringify(familyData));
            }
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('familywreathData');
            if (saved) {
                try {
                    familyData = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load saved data:', e);
                }
            }
        }
        
        // ============================================
        // GITHUB FUNCTIONS
        // ============================================
        async function loadFamilyFromGitHub() {
            try {
                const response = await fetch(`https://raw.githubusercontent.com/${GITHUB_OWNER}/${DATA_REPO}/${BRANCH}/${FAMILY_FILE}`);
                
                if (!response.ok) {
                    console.log('No published family tree yet');
                    return false;
                }
                
                const data = await response.json();
                
                if (validateFamilyData(data)) {
                    familyData = data;
                    render();
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error loading family tree from GitHub:', error);
                return false;
            }
        }

        function downloadFamilyWreathJSON() {
            if (!isAdmin) {
                alert('Only admins can download!');
                return;
            }
            
            try {
                const content = JSON.stringify(familyData, null, 2);
                
                // Download the JSON file
                const blob = new Blob([content], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'family-wreath.json';
                a.click();
                URL.revokeObjectURL(url);
                
                // Save to localStorage too
                saveToStorage();
                
                alert('‚úÖ Downloaded family-wreath.json!\n\nüìã Next step: Upload this file to github.com/ravenjones2912/HoregangData');
                
            } catch (error) {
                console.error('Error downloading:', error);
                alert('‚ùå Failed to download JSON file');
            }
        }

        function showExportImport() {
            const choice = prompt('Enter "export" to download JSON, or "import" to load JSON, or "reset" to clear localStorage:');
            
            if (choice === 'export') {
                exportJSON();
            } else if (choice === 'import') {
                importJSON();
            } else if (choice === 'reset') {
                if (confirm('This will delete all saved data and reload the default family. Continue?')) {
                    localStorage.removeItem('familywreathData');
                    location.reload();
                }
            }
        }

        function exportJSON() {
            const dataStr = JSON.stringify(familyData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'family-wreath.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (validateFamilyData(imported)) {
                            familyData = imported;
                            saveToStorage();
                            render();
                            alert('Import successful!');
                        } else {
                            alert('Invalid family data format.');
                        }
                    } catch (err) {
                        alert('Failed to parse JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function validateFamilyData(data) {
            return data && 
                   Array.isArray(data.people) && 
                   Array.isArray(data.relationships) && 
                   data.layout && 
                   typeof data.layout.positions === 'object';
        }

        // ============================================
        // MINIMAP
        // ============================================
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            // Pink background
            ctx.fillStyle = 'rgba(255, 192, 203, 0.3)';
            ctx.fillRect(0, 0, rect.width, rect.height);

            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            Object.values(familyData.layout.positions).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + 180);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + 150);
            });

            const width = maxX - minX;
            const height = maxY - minY;
            const scale = Math.min(rect.width / width, rect.height / height) * 0.8;

            // Draw nodes in pink
            ctx.fillStyle = '#ff69b4';
            familyData.people.forEach(person => {
                const pos = familyData.layout.positions[person.id];
                const x = (pos.x - minX) * scale + (rect.width - width * scale) / 2;
                const y = (pos.y - minY) * scale + (rect.height - height * scale) / 2;
                ctx.fillRect(x, y, 180 * scale, 150 * scale);
            });

            // Draw viewport
            const container = document.getElementById('canvas-container');
            const containerRect = container.getBoundingClientRect();
            const viewport = document.getElementById('minimap-viewport');
            
            const vpX = (-state.translateX / state.scale - minX) * scale + (rect.width - width * scale) / 2;
            const vpY = (-state.translateY / state.scale - minY) * scale + (rect.height - height * scale) / 2;
            const vpW = (containerRect.width / state.scale) * scale;
            const vpH = (containerRect.height / state.scale) * scale;
            
            viewport.style.left = vpX + 'px';
            viewport.style.top = vpY + 'px';
            viewport.style.width = vpW + 'px';
            viewport.style.height = vpH + 'px';
        }
        
        // ============================================
        // FLOATING HEARTS
        // ============================================
        setInterval(() => {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = ['üíñ', '‚ú®', 'üíï', '‚≠ê', 'üíó', 'üå∏'][Math.floor(Math.random() * 6)];
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDuration = (Math.random() * 5 + 5) + 's';
            document.body.appendChild(heart);
            
            setTimeout(() => heart.remove(), 10000);
        }, 500);

        // ============================================
        // INITIALIZATION
        // ============================================
        window.addEventListener('load', init);
    </script>
</body>
</html>

<!--
ACCEPTANCE CHECKLIST:
[‚úì] Pan works - Click and drag empty space to move around the canvas
[‚úì] Zoom works - Mouse wheel/trackpad zooms toward cursor with limits (0.3x - 2.5x)
[‚úì] Click opens character card - Clicking a Sim shows their full details in a modal
[‚úì] Search centers correctly - Type to search, click result centers and highlights the Sim
[‚úì] Drag rearrange updates lines - In Edit Mode, drag Sims to reposition; relationship lines update in real-time
[‚úì] localStorage save/load works - All changes persist automatically in browser storage
[‚úì] JSON import/export works - Export to download JSON file, Import to upload and restore data

BONUS FEATURES IMPLEMENTED:
[‚úì] Edit mode toggle - Right-click/long-press disabled in favor of double-click and dedicated UI
[‚úì] Add/Edit/Delete Sims via modal forms
[‚úì] Validation prevents impossible relationships (handled through UI constraints)
[‚úì] Mobile-friendly with touch support and pinch-to-zoom
[‚úì] Minimap showing viewport position
[‚úì] "Fit to Screen" and "Reset View" buttons
[‚úì] Relationship status indicators (married, divorced, dating)
[‚úì] Visual distinction for adoptive relationships (dashed lines)
[‚úì] Occult tag styling (vampire, spellcaster, ghost, mermaid, alien)
[‚úì] Character card with clickable relationship links
[‚úì] Zoom controls with on-screen buttons
[‚úì] 13-person seed family with multi-generation data, divorce, remarriage, adoption, and occult Sims
-->
