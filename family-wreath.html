<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>‚ú®üíñ Family Wreath üíñ‚ú®</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
        }

        body {
            font-family: 'Comic Neue', cursive;
            overflow: hidden;
            background:
                radial-gradient(circle at 20% 50%, rgba(255, 105, 180, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 20, 147, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(255, 182, 193, 0.3) 0%, transparent 50%),
                linear-gradient(135deg, #ff1493 0%, #ff69b4 25%, #ffc0cb 50%, #ff69b4 75%, #ff1493 100%);
            background-size: 100% 100%, 100% 100%, 100% 100%, 400% 400%;
            animation: gradient 15s ease infinite;
            color: #fff;
        }
        
        @keyframes gradient {
            0% { background-position: 0% 50%, 0% 50%, 0% 50%, 0% 50%; }
            50% { background-position: 100% 50%, 100% 50%, 100% 50%, 100% 50%; }
            100% { background-position: 0% 50%, 0% 50%, 0% 50%, 0% 50%; }
        }
        
        /* Sparkle overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, hotpink 1px, transparent 1px),
                radial-gradient(circle, #ffd700 1px, transparent 1px);
            background-size: 50px 50px, 80px 80px, 100px 100px;
            background-position: 0 0, 40px 60px, 130px 270px;
            animation: sparkle 3s linear infinite;
            pointer-events: none;
            opacity: 0.6;
            z-index: 1;
        }
        
        @keyframes sparkle {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            position: relative;
            z-index: 2;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 200px;
            height: 100vh;
            background: linear-gradient(180deg, 
                rgba(255, 20, 147, 0.95) 0%,
                rgba(255, 105, 180, 0.95) 50%,
                rgba(255, 192, 203, 0.95) 100%);
            padding: 20px;
            box-shadow: 8px 0 30px rgba(255, 20, 147, 0.6);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .sidebar-title {
            color: white;
            font-size: 1.5em;
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: bounce 2s ease infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .sidebar button, .sidebar input {
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            border: 3px solid white;
            border-radius: 15px;
            padding: 12px;
            color: white;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            transition: all 0.3s ease;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            font-family: 'Comic Neue', cursive;
        }
        
        .sidebar button:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
            background: linear-gradient(135deg, #ffd700, #ff69b4);
        }
        
        .sidebar button.active {
            background: linear-gradient(135deg, #ffd700, #ff1493);
            border-color: #ffd700;
            transform: scale(1.05);
        }
        
        .sidebar input {
            text-align: left;
            font-weight: normal;
        }
        
        .sidebar input::placeholder {
            color: rgba(255, 255, 255, 0.8);
            font-weight: normal;
        }

        /* Canvas Container */
        #canvas-container {
            margin-left: 200px;
            flex: 1;
            position: relative;
            overflow: hidden;
            background: 
                radial-gradient(circle, rgba(255, 255, 255, 0.4) 2px, transparent 2px),
                radial-gradient(circle at 20% 30%, rgba(255, 192, 203, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 80% 50%, rgba(173, 216, 230, 0.4) 0%, transparent 40%),
                radial-gradient(circle at 40% 80%, rgba(255, 240, 180, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 70% 20%, rgba(230, 255, 230, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 50% 60%, rgba(230, 200, 255, 0.4) 0%, transparent 40%),
                linear-gradient(135deg, 
                    rgba(230, 200, 255, 0.7) 0%,
                    rgba(255, 230, 200, 0.7) 20%,
                    rgba(200, 255, 230, 0.7) 40%,
                    rgba(255, 220, 230, 0.7) 60%,
                    rgba(200, 230, 255, 0.7) 80%,
                    rgba(245, 230, 255, 0.7) 100%
                );
            background-size: 30px 30px, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            animation: containerSwirl 15s ease infinite;
            cursor: grab;
        }
        
        @keyframes containerSwirl {
            0%, 100% { 
                background-position: 0 0, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 50%;
            }
            50% { 
                background-position: 30px 30px, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 50%;
            }
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        #canvas-container.edit-mode {
            cursor: default;
        }

        #canvas {
            position: absolute;
            width: 10000px;
            height: 10000px;
            transform-origin: 0 0;
        }

        /* Sim Node */
        .sim-node {
            position: absolute;
            width: 180px;
            background: linear-gradient(135deg, 
                rgba(255, 192, 203, 0.9),
                rgba(255, 240, 245, 0.95));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            padding: 12px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: all 0.3s ease;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            user-select: none;
            z-index: 10; /* Keep sim cards above relationship lines */
        }

        .sim-node:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 40px rgba(255, 20, 147, 0.6),
                inset 0 0 30px rgba(255, 255, 255, 0.4);
            border-image: linear-gradient(45deg, #ffd700, #ff1493, #ffd700) 1;
        }

        .sim-node.dragging {
            cursor: grabbing;
            box-shadow: 
                0 15px 50px rgba(255, 20, 147, 0.8),
                inset 0 0 40px rgba(255, 255, 255, 0.5);
            z-index: 1000;
        }

        .sim-node.highlighted {
            border-image: linear-gradient(45deg, #ffd700, #ff1493, #ffd700) 1;
            box-shadow: 
                0 0 40px rgba(255, 215, 0, 0.9),
                0 12px 40px rgba(255, 20, 147, 0.6),
                inset 0 0 30px rgba(255, 255, 255, 0.4);
            animation: pulse 1.5s ease-in-out 3;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        .sim-portrait {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            border: 3px solid white;
            box-shadow: 
                0 4px 15px rgba(255, 20, 147, 0.5),
                inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .sim-portrait.no-image {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sim-name {
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 4px;
            text-align: center;
            color: #ff1493;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .sim-lifestage {
            font-size: 12px;
            color: #8b008b;
            text-align: center;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .sim-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            margin-top: 6px;
        }

        .sim-tag {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: #fff;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(255, 20, 147, 0.4);
            border: 2px solid white;
        }

        .sim-tag.vampire { background: linear-gradient(135deg, #8b0000, #ff1493); }
        .sim-tag.spellcaster { background: linear-gradient(135deg, #9370db, #ff69b4); }
        .sim-tag.ghost { background: linear-gradient(135deg, #c0c0c0, #ffd700); }
        .sim-tag.mermaid { background: linear-gradient(135deg, #20b2aa, #ff69b4); }
        .sim-tag.alien { background: linear-gradient(135deg, #32cd32, #ffd700); }

        /* SVG Lines for relationships */
        #relationship-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .relationship-line {
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 4px rgba(255, 105, 180, 0.6));
        }

        .relationship-line.parent {
            stroke: #ff69b4;
            stroke-dasharray: none;
        }

        .relationship-line.partner {
            stroke: #ffd700;
            stroke-width: 4;
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8));
        }

        .relationship-line.adoptive {
            stroke: #ff1493;
            stroke-dasharray: 10, 5;
            filter: drop-shadow(0 0 4px rgba(255, 20, 147, 0.6));
        }

        /* Character Card Modal */
        #character-card-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 20, 147, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #character-card-modal.show {
            display: flex;
        }

        .character-card {
            background: linear-gradient(135deg, 
                rgba(255, 192, 203, 0.98),
                rgba(255, 240, 245, 0.98));
            border: 6px solid;
            border-image: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493) 1;
            border-radius: 20px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(255, 20, 147, 0.8),
                0 0 80px rgba(255, 105, 180, 0.6),
                inset 0 0 50px rgba(255, 192, 203, 0.3);
            position: relative;
        }

        .character-card h2 {
            background: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 3s ease infinite;
            margin-bottom: 16px;
            font-size: 24px;
            text-shadow: 
                2px 2px 0px rgba(255, 105, 180, 0.3),
                4px 4px 0px rgba(255, 182, 193, 0.2);
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
        }
        
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .character-card .close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            color: #fff;
            border: 3px solid white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            font-size: 20px;
            line-height: 1;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.5);
            font-weight: bold;
        }

        .character-card .close-btn:hover {
            background: linear-gradient(135deg, #ffd700, #ff1493);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.7);
        }

        .character-card-section {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700) 1;
            box-shadow: 
                0 4px 15px rgba(255, 105, 180, 0.3),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .character-card-section h3 {
            color: #ff1493;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .character-card-section p,
        .character-card-section ul {
            color: #8b008b;
            line-height: 1.6;
            font-weight: 600;
        }

        .character-card-section ul {
            list-style: none;
            padding: 0;
        }

        .character-card-section li {
            padding: 6px 0;
            border-bottom: 2px solid rgba(255, 105, 180, 0.2);
        }

        .character-card-section li:last-child {
            border-bottom: none;
        }

        .character-link {
            color: #ff1493;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            text-decoration: underline;
            transition: color 0.2s;
            font-weight: 700;
        }

        .character-link:hover {
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
        }

        /* Edit Modal */
        #edit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 20, 147, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #edit-modal.show {
            display: flex;
        }

        .edit-modal-content {
            background: linear-gradient(135deg, 
                rgba(255, 192, 203, 0.98),
                rgba(255, 240, 245, 0.98));
            border: 6px solid;
            border-image: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493) 1;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(255, 20, 147, 0.8),
                0 0 80px rgba(255, 105, 180, 0.6),
                inset 0 0 50px rgba(255, 192, 203, 0.3);
        }

        .edit-modal-content h2 {
            background: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 3s ease infinite;
            margin-bottom: 20px;
            font-size: 24px;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #ff1493;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700) 1;
            border-radius: 12px;
            color: #8b008b;
            font-size: 14px;
            font-family: 'Comic Neue', cursive;
            font-weight: 600;
            box-shadow: 
                0 4px 15px rgba(255, 105, 180, 0.2),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-image: linear-gradient(45deg, #ffd700, #ff1493) 1;
            box-shadow: 
                0 0 20px rgba(255, 215, 0, 0.5),
                inset 0 0 15px rgba(255, 255, 255, 0.6);
        }

        .form-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .form-buttons button {
            flex: 1;
            padding: 12px;
            border: 3px solid white;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 700;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: all 0.3s ease;
            font-family: 'Comic Neue', cursive;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.4);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            color: #fff;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #ffd700, #ff69b4);
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            color: #fff;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #8b0000, #ff1493);
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 0, 0, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #c0c0c0, #e0e0e0);
            color: #8b008b;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #e0e0e0, #c0c0c0);
            transform: scale(1.05) translateY(-2px);
        }

        .multi-select-container {
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700) 1;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
            box-shadow: inset 0 0 10px rgba(255, 192, 203, 0.3);
        }

        .multi-select-item {
            padding: 6px 10px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            border-radius: 8px;
            transition: background 0.2s;
            margin-bottom: 4px;
            color: #8b008b;
            font-weight: 600;
        }

        .multi-select-item:hover {
            background: rgba(255, 192, 203, 0.5);
        }

        .multi-select-item.selected {
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Context Menu */
        #context-menu {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.98), rgba(255, 240, 245, 0.98));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            z-index: 3000;
            min-width: 180px;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: background 0.2s;
            border-bottom: 2px solid rgba(255, 105, 180, 0.3);
            color: #ff1493;
            font-weight: 700;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: rgba(255, 215, 0, 0.4);
        }

        /* Zoom Controls */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        #zoom-controls button {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ff69b4, #ffd700);
            border: 3px solid white;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: 700;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.5);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #zoom-controls button:hover {
            background: linear-gradient(135deg, #ffd700, #ff1493);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.7);
        }

        .zoom-level {
            text-align: center;
            font-size: 14px;
            color: #ff1493;
            margin: 4px 0;
            font-weight: 700;
            text-shadow: 
                1px 1px 2px rgba(255, 255, 255, 0.8),
                0 0 10px rgba(255, 215, 0, 0.6);
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .sidebar {
                width: 160px;
                padding: 12px;
            }

            .sidebar button {
                padding: 10px;
                font-size: 0.9em;
            }

            #canvas-container {
                margin-left: 160px;
            }

            .sim-node {
                width: 150px;
            }

            .character-card {
                width: 95%;
                max-height: 85vh;
                padding: 16px;
            }
            
            .family-wreath-title {
                font-size: 2.5em !important;
                top: 15px !important;
            }
            
            .family-wreath-subtitle {
                font-size: 1.1em !important;
                top: 70px !important;
            }
            
            .search-bar-container {
                top: 110px !important;
            }
            
            .search-bar-container #search-input {
                width: 280px !important;
                font-size: 14px !important;
                padding: 10px 16px !important;
            }
            
            .search-bar-container #search-results {
                width: 280px !important;
            }
        }
        
        /* Family Wreath Title */
        .family-wreath-title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
            background: linear-gradient(45deg, #ff1493, #ff69b4, #ffd700, #ff69b4, #ff1493);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3.5em;
            margin: 0 0 5px 0;
            text-shadow: 
                3px 3px 0px rgba(255, 105, 180, 0.5),
                6px 6px 0px rgba(255, 182, 193, 0.3);
            animation: rainbowText 3s ease infinite;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
            letter-spacing: 3px;
            pointer-events: none;
        }
        
        .family-wreath-subtitle {
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
            color: #ff1493;
            font-size: 1.4em;
            margin: 0;
            font-weight: bold;
            text-shadow: 
                2px 2px 0px #ffc0cb,
                -1px -1px 0px #ff69b4;
            animation: bounce 2s ease infinite;
            pointer-events: none;
        }
        
        /* Search Bar Container */
        .search-bar-container {
            position: fixed;
            top: 135px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
        }
        
        .search-bar-container #search-input {
            padding: 12px 20px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.95);
            color: #8b008b;
            font-size: 16px;
            width: 350px;
            font-family: 'Comic Neue', cursive;
            font-weight: 600;
            box-shadow: 
                0 4px 15px rgba(255, 105, 180, 0.4),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .search-bar-container #search-input:focus {
            outline: none;
            border-image: linear-gradient(45deg, #ffd700, #ff1493, #ffd700) 1;
            box-shadow: 
                0 0 25px rgba(255, 215, 0, 0.6),
                inset 0 0 15px rgba(255, 255, 255, 0.6);
            transform: scale(1.02);
        }
        
        .search-bar-container #search-input::placeholder {
            color: rgba(139, 0, 139, 0.6);
        }
        
        .search-bar-container #search-results {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.98), rgba(255, 240, 245, 0.98));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            width: 350px;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        .search-result-item {
            padding: 10px 14px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="hotpink"/></svg>'), auto;
            border-bottom: 2px solid rgba(255, 105, 180, 0.3);
            transition: background 0.2s;
            color: #ff1493;
            font-weight: bold;
        }

        .search-result-item:hover {
            background: rgba(255, 215, 0, 0.3);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }
        
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 120px;
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.95), rgba(255, 240, 245, 0.95));
            border: 4px solid;
            border-image: linear-gradient(45deg, #ff69b4, #ffd700, #ff69b4) 1;
            border-radius: 15px;
            z-index: 100;
            overflow: hidden;
            box-shadow: 
                0 8px 32px rgba(255, 20, 147, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .minimap-viewport {
            position: absolute;
            border: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.2);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        /* Floating hearts animation */
        @keyframes floatUp {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .heart {
            position: fixed;
            bottom: -50px;
            font-size: 30px;
            animation: floatUp 10s linear forwards;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Sidebar Navigation -->
        <div class="sidebar">
            <div class="sidebar-title">üíñ MENU üíñ</div>
            
            <div id="statusIndicator" style="padding: 10px; margin: 10px 0; border-radius: 10px; font-size: 0.9em; text-align: center; font-weight: bold;"></div>
            
            <button id="publishBtn" onclick="downloadFamilyWreathJSON()" style="
                display: none;
                background: linear-gradient(135deg, #32cd32, #228b22);
                border: 3px solid white;
                border-radius: 12px;
                padding: 12px;
                color: white;
                font-size: 1em;
                font-weight: bold;
                font-family: 'Comic Neue', cursive;
                cursor: pointer;
                width: 100%;
                margin-bottom: 10px;
                box-shadow: 0 4px 15px rgba(50, 205, 50, 0.6);
                transition: all 0.3s ease;
            ">üì• Download family-wreath.json</button>
            <div id="publishHint" style="display: none; margin-bottom: 10px; color: #006400; font-size: 0.8em; text-align: center;">
                Download, then upload to <a href="https://github.com/ravenjones2912/hortensiashausdata" target="_blank" style="color: #228b22; font-weight: bold;">hortensiashausdata repo</a>
            </div>
            
            <button onclick="window.location.href='home.html'">üè† Home</button>
            <button id="addSimBtn" onclick="addNewSim()">‚ûï Add a Sim</button>
            <button id="edit-mode-btn" onclick="toggleEditMode()">‚úèÔ∏è Edit Mode</button>
            <button id="ruler-btn" onclick="toggleRuler()" style="display: none;">üìè Ruler</button>
            <button id="emoji-btn" onclick="toggleEmojiPicker()" style="display: none;">üíï Add Emoji</button>
            <button id="pen-btn" onclick="togglePenTool()" style="display: none;">‚úèÔ∏è Pen Tool</button>
            <button onclick="resetView()">üîÑ Reset View</button>
            <button onclick="fitToScreen()">üìê Fit All</button>
            <button onclick="logout()" style="margin-top: auto;">üîí Logout</button>
        </div>

        <!-- Canvas Container -->
        <div id="canvas-container">
            <h1 class="family-wreath-title">Family Wreath</h1>
            <div class="family-wreath-subtitle">üó°Ô∏èCo-Produced by the ghost of VC Andrewsüó°Ô∏è</div>
            <div class="search-bar-container">
                <input type="text" id="search-input" placeholder="üîç Search Sim by name..." oninput="handleSearch()">
                <div id="search-results"></div>
            </div>
            <div id="canvas">
                <svg id="relationship-svg"></svg>
            </div>

            <!-- Zoom Controls -->
            <div id="zoom-controls">
                <button onclick="zoomIn()">+</button>
                <div class="zoom-level" id="zoom-level">100%</div>
                <button onclick="zoomOut()">‚àí</button>
            </div>

            <!-- Minimap -->
            <div id="minimap">
                <canvas id="minimap-canvas"></canvas>
                <div class="minimap-viewport" id="minimap-viewport"></div>
            </div>
        </div>
    </div>

    <!-- Drawing Canvas Layer (for pen tool) -->
    <canvas id="drawing-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5;"></canvas>

    <!-- Custom Connector Lines (SVG overlay so lines move with cards) -->
    <svg id="custom-lines-svg" style="position: absolute; top: 0; left: 200px; width: calc(100vw - 200px); height: 100vh; pointer-events: none; z-index: 4;"></svg>

    <!-- Ruler Tool -->
    <div id="ruler" style="display: none; position: absolute; width: 400px; height: 40px; background: rgba(255, 192, 203, 0.9); border: 3px solid #ff69b4; border-radius: 8px; z-index: 100; box-shadow: 0 4px 15px rgba(255, 105, 180, 0.6); pointer-events: auto;">
        <div id="ruler-body" style="display: flex; justify-content: space-between; align-items: center; height: 100%; padding: 0 10px; cursor: move;">
            <div style="flex: 1; display: flex; justify-content: space-between; font-size: 10px; color: #ff1493; font-weight: bold; pointer-events: none;">
                <span>|</span><span>|</span><span>|</span><span>|</span><span>|</span><span>|</span><span>|</span><span>|</span><span>|</span><span>|</span>
            </div>
            <button onclick="rotateRuler()" style="background: #ff69b4; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 10px; pointer-events: auto;">‚Üª Rotate</button>
            <button onclick="closeRuler()" style="background: #ff1493; border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 5px; pointer-events: auto;">√ó</button>
        </div>
    </div>

    <!-- Emoji Picker -->
    <div id="emoji-picker" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(255, 192, 203, 0.98), rgba(255, 240, 245, 0.98)); border: 4px solid #ff69b4; border-radius: 20px; padding: 30px; z-index: 1000; box-shadow: 0 10px 40px rgba(255, 20, 147, 0.6);">
        <h3 style="color: #ff1493; text-align: center; margin-bottom: 20px; font-family: 'Comic Neue', cursive;">üíï Choose an Emoji</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px;">
            <button onclick="addEmoji('‚ù§Ô∏è')" style="font-size: 48px; background: white; border: 3px solid #ff69b4; border-radius: 15px; padding: 20px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚ù§Ô∏è</button>
            <button onclick="addEmoji('üíî')" style="font-size: 48px; background: white; border: 3px solid #ff69b4; border-radius: 15px; padding: 20px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">üíî</button>
            <button onclick="addEmoji('‚ù§Ô∏è‚Äçüî•')" style="font-size: 48px; background: white; border: 3px solid #ff69b4; border-radius: 15px; padding: 20px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚ù§Ô∏è‚Äçüî•</button>
        </div>
        <button onclick="closeEmojiPicker()" style="width: 100%; background: linear-gradient(135deg, #ff69b4, #ff1493); border: none; color: white; padding: 12px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; font-family: 'Comic Neue', cursive;">Close</button>
    </div>

    <!-- Pen Tool Panel -->
    <div id="pen-tool-panel" style="display: none; position: fixed; top: 80px; left: 180px; background: linear-gradient(135deg, rgba(255, 192, 203, 0.98), rgba(255, 240, 245, 0.98)); border: 4px solid #ff69b4; border-radius: 20px; padding: 30px; z-index: 1000; box-shadow: 0 10px 40px rgba(255, 20, 147, 0.6); min-width: 300px; cursor: move;">
        <h3 style="color: #ff1493; text-align: center; margin-bottom: 20px; font-family: 'Comic Neue', cursive;">‚úèÔ∏è Pen Tool</h3>
        
        <div style="margin-bottom: 20px;">
            <label style="color: #ff1493; font-weight: bold; display: block; margin-bottom: 8px;">Pen Type:</label>
            <select id="pen-type" onchange="updatePenType()" style="width: 100%; padding: 10px; border: 2px solid #ff69b4; border-radius: 8px; font-family: 'Comic Neue', cursive; background: white;">
                <option value="solid">Solid Line</option>
                <option value="dashed">Dashed Line</option>
                <option value="dotted">Dotted Line</option>
            </select>
        </div>

        <div style="margin-bottom: 20px;">
            <label style="color: #ff1493; font-weight: bold; display: block; margin-bottom: 8px;">Line Width:</label>
            <input type="range" id="pen-width" min="1" max="10" value="3" onchange="updatePenWidth()" style="width: 100%;">
            <span id="pen-width-display" style="color: #ff1493; font-size: 14px;">3px</span>
        </div>

        <div style="margin-bottom: 20px;">
            <label style="color: #ff1493; font-weight: bold; display: block; margin-bottom: 8px;">Color:</label>
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;">
                <button onclick="setPenColor('#000000')" style="width: 40px; height: 40px; background: #000000; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#ff1493')" style="width: 40px; height: 40px; background: #ff1493; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#ff69b4')" style="width: 40px; height: 40px; background: #ff69b4; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#ffd700')" style="width: 40px; height: 40px; background: #ffd700; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#ffffff')" style="width: 40px; height: 40px; background: #ffffff; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#0000ff')" style="width: 40px; height: 40px; background: #0000ff; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#00ff00')" style="width: 40px; height: 40px; background: #00ff00; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#ff0000')" style="width: 40px; height: 40px; background: #ff0000; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#800080')" style="width: 40px; height: 40px; background: #800080; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
                <button onclick="setPenColor('#ffa500')" style="width: 40px; height: 40px; background: #ffa500; border: 3px solid #ff69b4; border-radius: 8px; cursor: pointer;"></button>
            </div>
        </div>

        <div style="display: flex; gap: 10px;">
            <button id="draw-btn" onclick="startDrawing()" style="flex: 1; background: linear-gradient(135deg, #32cd32, #228b22); border: none; color: white; padding: 12px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; font-family: 'Comic Neue', cursive;">‚úèÔ∏è Draw</button>
            <button id="erase-btn" onclick="startErasing()" style="flex: 1; background: linear-gradient(135deg, #ffa500, #ff8c00); border: none; color: white; padding: 12px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; font-family: 'Comic Neue', cursive;">üßπ Erase</button>
            <button onclick="clearAllDrawings()" style="flex: 1; background: linear-gradient(135deg, #ff1493, #dc143c); border: none; color: white; padding: 12px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; font-family: 'Comic Neue', cursive;">üóëÔ∏è Clear All</button>
        </div>
        
        <button id="remove-connector-btn" onclick="toggleRemoveConnectorMode()" style="width: 100%; margin-top: 10px; background: linear-gradient(135deg, #dc143c, #8b0000); border: none; color: white; padding: 12px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; font-family: 'Comic Neue', cursive;">üîó‚ùå Remove Connector Lines</button>
        
        <button onclick="closePenTool()" style="width: 100%; margin-top: 10px; background: linear-gradient(135deg, #ff69b4, #ff1493); border: none; color: white; padding: 12px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; font-family: 'Comic Neue', cursive;">Close</button>
    </div>

    <!-- Character Card Modal -->
    <div id="character-card-modal" onclick="closeCharacterCard(event)">
        <div class="character-card" onclick="event.stopPropagation()">
            <button class="close-btn" onclick="closeCharacterCard()">√ó</button>
            <div id="character-card-content"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" onclick="closeEditModal(event)">
        <div class="edit-modal-content" onclick="event.stopPropagation()">
            <h2 id="edit-modal-title">Add Sim</h2>
            <div class="form-group">
                <label>Name *</label>
                <input type="text" id="edit-name" required>
            </div>
            <div class="form-group">
                <label>Portrait</label>
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                    <button type="button" class="btn-secondary" style="flex: 0 0 auto; padding: 8px 12px;" onclick="document.getElementById('portrait-upload').click()">üì∑ Upload Image</button>
                    <input type="file" id="portrait-upload" accept="image/*" style="display: none;" onchange="handlePortraitUpload(event)">
                    <span id="portrait-filename" style="font-size: 12px; color: #8b008b; font-weight: 600;"></span>
                </div>
                <input type="text" id="edit-portrait" placeholder="Or enter an emoji (e.g., üë®)">
                <div id="portrait-preview" style="margin-top: 10px; text-align: center;"></div>
            </div>
            <div class="form-group">
                <label>Lifestage</label>
                <select id="edit-lifestage">
                    <option value="Baby">Baby</option>
                    <option value="Toddler">Toddler</option>
                    <option value="Child">Child</option>
                    <option value="Teen">Teen</option>
                    <option value="Young Adult">Young Adult</option>
                    <option value="Adult" selected>Adult</option>
                    <option value="Elder">Elder</option>
                </select>
            </div>
            <div class="form-group">
                <label>Tags (comma-separated: vampire, spellcaster, ghost, mermaid, alien)</label>
                <input type="text" id="edit-tags" placeholder="e.g., vampire, spellcaster">
            </div>
            <div class="form-group">
                <label>Traits (comma-separated)</label>
                <input type="text" id="edit-traits" placeholder="e.g., Ambitious, Creative, Hot-headed">
            </div>
            <div class="form-group">
                <label>Bio/Notes</label>
                <textarea id="edit-bio"></textarea>
            </div>
            <div class="form-group">
                <label>Life Events (one per line)</label>
                <textarea id="edit-events" placeholder="e.g., Moved to Willow Creek&#10;Opened a bakery"></textarea>
            </div>
            <div class="form-group">
                <label>Parents (select multiple)</label>
                <div class="multi-select-container" id="edit-parents"></div>
            </div>
            <div class="form-group">
                <label>Partners/Spouses (select multiple)</label>
                <div class="multi-select-container" id="edit-partners"></div>
            </div>
            <div class="form-buttons">
                <button class="btn-primary" onclick="saveEditedSim()">Save</button>
                <button class="btn-danger" id="delete-sim-btn" onclick="deleteCurrentSim()" style="display:none;">Delete</button>
                <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-item" onclick="addSimFromContext()">Add Sim Here</div>
        <div class="context-menu-item" onclick="addRelationship()">Add Relationship</div>
    </div>

    <script>
        // ============================================
        // LOGIN PROTECTION
        // ============================================
        if (sessionStorage.getItem('dynastyLoggedIn') !== 'true') {
            window.location.href = 'index.html';
        }
        
        // ============================================
        // GITHUB CONFIGURATION (NO TOKEN NEEDED)
        // ============================================
        const GITHUB_OWNER = 'ravenjones2912';
        const DATA_REPO = 'hortensiashausdata';
        const BRANCH = 'main';
        const FAMILY_FILE = 'family-wreath.json';
        const isAdmin = sessionStorage.getItem('dynastyUser') === 'admin';
        
        console.log('Current user:', sessionStorage.getItem('dynastyUser'));
        console.log('Is admin?', isAdmin);
        
        // ============================================
        // LOGOUT FUNCTION
        // ============================================
        function logout() {
            sessionStorage.removeItem('dynastyLoggedIn');
            sessionStorage.removeItem('dynastyUser');
            window.location.href = 'index.html';
        }
        
        // ============================================
        // DATA MODEL
        // ============================================
        let familyData = {
            people: [],
            relationships: [],
            layout: {
                positions: {}
            }
        };

        // ============================================
        // STATE
        // ============================================
        let state = {
            scale: 1,
            translateX: 0,
            translateY: 0,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            draggedNode: null,
            editMode: false,
            currentEditingId: null,
            contextMenuPos: { x: 0, y: 0 }
        };

        const MIN_SCALE = 0.3;
        const MAX_SCALE = 2.5;
        const ZOOM_SPEED = 0.1;

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            // Initialize based on mode
            if (isAdmin) {
                document.getElementById('statusIndicator').innerHTML = 'üëë ADMIN MODE';
                document.getElementById('statusIndicator').style.cssText = 'background: rgba(255, 215, 0, 0.3); border: 2px solid #ffd700; color: #ff1493;';
                document.getElementById('publishBtn').style.display = 'block';
                document.getElementById('publishHint').style.display = 'block';
                
                // Show drawing tools for admin
                document.getElementById('ruler-btn').style.display = 'block';
                document.getElementById('emoji-btn').style.display = 'block';
                document.getElementById('pen-btn').style.display = 'block';
                
                // Admin: Load from GitHub to see published version (same as visitors)
                const loaded = await loadFamilyFromGitHub();
                if (!loaded) {
                    // If no published version, load defaults
                    loadFromStorage();
                }
            } else {
                document.getElementById('statusIndicator').innerHTML = 'üëÄ VISITOR MODE';
                document.getElementById('statusIndicator').style.cssText = 'background: rgba(144, 238, 144, 0.3); border: 2px solid #90ee90; color: #006400;';
                // Hide admin-only buttons for visitors
                document.getElementById('addSimBtn').style.display = 'none';
                document.getElementById('edit-mode-btn').style.display = 'none';
                document.getElementById('saveLoadBtn').style.display = 'none';
                
                // Load from GitHub for visitors
                const loaded = await loadFamilyFromGitHub();
                if (!loaded) {
                    // If no published version, load defaults
                    loadFromStorage();
                }
            }
            
            setupEventListeners();
            centerView();
            render();
        }

        function setupEventListeners() {
            const container = document.getElementById('canvas-container');
            
            // Pan
            container.addEventListener('mousedown', handleMouseDown);
            container.addEventListener('mousemove', handleMouseMove);
            container.addEventListener('mouseup', handleMouseUp);
            container.addEventListener('mouseleave', handleMouseUp);

            // Zoom
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Touch events
            container.addEventListener('touchstart', handleTouchStart, { passive: false });
            container.addEventListener('touchmove', handleTouchMove, { passive: false });
            container.addEventListener('touchend', handleTouchEnd);

            // Context menu
            container.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', () => {
                document.getElementById('context-menu').style.display = 'none';
            });

            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#search-input') && !e.target.closest('#search-results')) {
                    document.getElementById('search-results').style.display = 'none';
                }
            });
        }

        // ============================================
        // PORTRAIT UPLOAD
        // ============================================
        let uploadedPortraitData = null;
        
        function handlePortraitUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedPortraitData = e.target.result;
                document.getElementById('portrait-filename').textContent = file.name;
                document.getElementById('edit-portrait').value = ''; // Clear emoji field
                
                // Show preview
                const preview = document.getElementById('portrait-preview');
                preview.innerHTML = `<img src="${uploadedPortraitData}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid #ff69b4; box-shadow: 0 4px 15px rgba(255, 105, 180, 0.5);">`;
            };
            reader.readAsDataURL(file);
        }
        
        // ============================================
        // RENDERING
        // ============================================
        function render() {
            renderNodes();
            renderRelationships();
            updateTransform();
            renderCustomLines();
            updateMinimap();
        }

        function renderNodes() {
            const canvas = document.getElementById('canvas');
            // Remove existing nodes
            const existingNodes = canvas.querySelectorAll('.sim-node');
            existingNodes.forEach(node => node.remove());

            familyData.people.forEach(person => {
                const pos = familyData.layout.positions[person.id] || { x: 0, y: 0 };
                const node = createNodeElement(person, pos);
                canvas.appendChild(node);
            });
        }

        function createNodeElement(person, pos) {
            const node = document.createElement('div');
            node.className = 'sim-node';
            node.id = `node-${person.id}`;
            node.style.left = `${pos.x}px`;
            node.style.top = `${pos.y}px`;
            node.dataset.personId = person.id;

            // Portrait
            const portrait = document.createElement('div');
            portrait.className = 'sim-portrait';
            if (person.portrait) {
                if (person.portrait.startsWith('data:image/')) {
                    // It's an uploaded image
                    portrait.style.backgroundImage = `url(${person.portrait})`;
                    portrait.style.backgroundSize = 'cover';
                    portrait.style.backgroundPosition = 'center';
                } else {
                    // It's an emoji
                    portrait.textContent = person.portrait;
                }
            } else {
                portrait.className += ' no-image';
                portrait.textContent = person.name.split(' ').map(n => n[0]).join('');
            }

            // Name
            const name = document.createElement('div');
            name.className = 'sim-name';
            name.textContent = person.name;

            // Lifestage
            const lifestage = document.createElement('div');
            lifestage.className = 'sim-lifestage';
            lifestage.textContent = person.lifestage || '';

            // Tags
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'sim-tags';
            person.tags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = `sim-tag ${tag.toLowerCase()}`;
                tagEl.textContent = tag;
                tagsContainer.appendChild(tagEl);
            });

            node.appendChild(portrait);
            node.appendChild(name);
            node.appendChild(lifestage);
            node.appendChild(tagsContainer);

            // Event handlers
            node.addEventListener('click', (e) => {
                if (!state.editMode) {
                    e.stopPropagation();
                    showCharacterCard(person.id);
                }
            });

            if (state.editMode) {
                node.addEventListener('mousedown', (e) => startDragNode(e, person.id));
                node.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    editSim(person.id);
                });
            }

            return node;
        }

        function renderRelationships() {
            // Automatic line generation disabled - user draws their own lines!
            // Lines drawn manually are stored separately in familyData.customDrawings
            return;
        }

        function updateTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
            document.getElementById('zoom-level').textContent = `${Math.round(state.scale * 100)}%`;
            // Keep connector lines stuck to cards during pan/zoom
            renderCustomLines();
        }

        // ============================================
        // PAN & ZOOM
        // ============================================
        function handleMouseDown(e) {
            if (e.target.id === 'canvas-container' || e.target.id === 'canvas' || e.target.id === 'relationship-svg') {
                state.isDragging = true;
                state.dragStartX = e.clientX - state.translateX;
                state.dragStartY = e.clientY - state.translateY;
                document.getElementById('canvas-container').classList.add('dragging');
            }
        }

        function handleMouseMove(e) {
            if (state.isDragging && !state.draggedNode) {
                state.translateX = e.clientX - state.dragStartX;
                state.translateY = e.clientY - state.dragStartY;
                updateTransform();
            } else if (state.draggedNode) {
                const rect = document.getElementById('canvas').getBoundingClientRect();
                const x = (e.clientX - rect.left) / state.scale;
                const y = (e.clientY - rect.top) / state.scale;
                
                familyData.layout.positions[state.draggedNode] = { 
                    x: x - 90, 
                    y: y - 65 
                };
                render();
            }
        }

        function handleMouseUp() {
            state.isDragging = false;
            document.getElementById('canvas-container').classList.remove('dragging');
            
            if (state.draggedNode) {
                saveToStorage();
                state.draggedNode = null;
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Get mouse position relative to container
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate position in canvas before zoom
            const canvasX = (mouseX - state.translateX) / state.scale;
            const canvasY = (mouseY - state.translateY) / state.scale;
            
            // Update scale
            const delta = -Math.sign(e.deltaY) * ZOOM_SPEED;
            const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, state.scale + delta));
            
            // Calculate new translation to keep mouse position fixed
            state.translateX = mouseX - canvasX * newScale;
            state.translateY = mouseY - canvasY * newScale;
            state.scale = newScale;
            
            updateTransform();
        }

        function zoomIn() {
            const newScale = Math.min(MAX_SCALE, state.scale + ZOOM_SPEED);
            zoomToCenter(newScale);
        }

        function zoomOut() {
            const newScale = Math.max(MIN_SCALE, state.scale - ZOOM_SPEED);
            zoomToCenter(newScale);
        }

        function zoomToCenter(newScale) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const canvasX = (centerX - state.translateX) / state.scale;
            const canvasY = (centerY - state.translateY) / state.scale;
            
            state.translateX = centerX - canvasX * newScale;
            state.translateY = centerY - canvasY * newScale;
            state.scale = newScale;
            
            updateTransform();
        }

        function resetView() {
            state.scale = 1;
            centerView();
        }

        function centerView() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Find bounds of all nodes
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            Object.values(familyData.layout.positions).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + 180);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + 150);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Account for the search bar and title at the top (about 200px)
            const effectiveHeight = rect.height - 200;
            const effectiveCenterY = rect.height / 2 + 100;
            
            state.translateX = rect.width / 2 - centerX * state.scale;
            state.translateY = effectiveCenterY - centerY * state.scale;
            
            updateTransform();
        }

        function fitToScreen() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            Object.values(familyData.layout.positions).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + 180);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + 150);
            });
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            // Account for search bar and title
            const effectiveHeight = rect.height - 250;
            
            const scaleX = (rect.width - 100) / width;
            const scaleY = (effectiveHeight - 100) / height;
            state.scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, Math.min(scaleX, scaleY)));
            
            centerView();
        }

        // ============================================
        // TOUCH EVENTS
        // ============================================
        let touchStartDist = 0;
        let touchStartScale = 1;

        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartDist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                touchStartScale = state.scale;
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                state.isDragging = true;
                state.dragStartX = touch.clientX - state.translateX;
                state.dragStartY = touch.clientY - state.translateY;
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, 
                    touchStartScale * (dist / touchStartDist)));
                state.scale = newScale;
                updateTransform();
            } else if (e.touches.length === 1 && state.isDragging) {
                const touch = e.touches[0];
                state.translateX = touch.clientX - state.dragStartX;
                state.translateY = touch.clientY - state.dragStartY;
                updateTransform();
            }
        }

        function handleTouchEnd() {
            state.isDragging = false;
            touchStartDist = 0;
        }

        // ============================================
        // NODE DRAGGING (Edit Mode)
        // ============================================
        function startDragNode(e, personId) {
            if (!state.editMode) return;
            e.stopPropagation();
            state.draggedNode = personId;
            const node = document.getElementById(`node-${personId}`);
            node.classList.add('dragging');
        }

        // ============================================
        // CHARACTER CARD
        // ============================================
        function showCharacterCard(personId) {
            const person = familyData.people.find(p => p.id === personId);
            if (!person) return;

            const content = document.getElementById('character-card-content');
            let html = `<h2>${person.name}</h2>`;

            // Lifestage & Tags
            if (person.lifestage) {
                html += `<div class="character-card-section">
                    <h3>Lifestage</h3>
                    <p>${person.lifestage}</p>
                </div>`;
            }

            if (person.tags && person.tags.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Occult Type</h3>
                    <p>${person.tags.join(', ')}</p>
                </div>`;
            }

            // Bio
            if (person.bio) {
                html += `<div class="character-card-section">
                    <h3>Bio</h3>
                    <p>${person.bio}</p>
                </div>`;
            }

            // Traits
            if (person.traits && person.traits.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Traits</h3>
                    <p>${person.traits.join(', ')}</p>
                </div>`;
            }

            // Life Events
            if (person.events && person.events.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Life Events</h3>
                    <ul>`;
                person.events.forEach(event => {
                    html += `<li>${event}</li>`;
                });
                html += `</ul></div>`;
            }

            // Relationships
            const partners = familyData.relationships
                .filter(r => r.type === 'partner' && (r.from === personId || r.to === personId))
                .map(r => {
                    const partnerId = r.from === personId ? r.to : r.from;
                    const partner = familyData.people.find(p => p.id === partnerId);
                    return partner ? `<span class="character-link" onclick="centerOnSim('${partnerId}')">${partner.name}</span> (${r.status})` : '';
                })
                .filter(p => p);

            if (partners.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Partners</h3>
                    <p>${partners.join('<br>')}</p>
                </div>`;
            }

            const parents = familyData.relationships
                .filter(r => r.type === 'parent' && r.to === personId)
                .map(r => {
                    const parent = familyData.people.find(p => p.id === r.from);
                    return parent ? `<span class="character-link" onclick="centerOnSim('${r.from}')">${parent.name}</span>` : '';
                })
                .filter(p => p);

            if (parents.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Parents</h3>
                    <p>${parents.join(', ')}</p>
                </div>`;
            }

            const children = familyData.relationships
                .filter(r => r.type === 'parent' && r.from === personId)
                .map(r => {
                    const child = familyData.people.find(p => p.id === r.to);
                    return child ? `<span class="character-link" onclick="centerOnSim('${r.to}')">${child.name}</span>` : '';
                })
                .filter(c => c);

            if (children.length > 0) {
                html += `<div class="character-card-section">
                    <h3>Children</h3>
                    <p>${children.join(', ')}</p>
                </div>`;
            }

            content.innerHTML = html;
            document.getElementById('character-card-modal').classList.add('show');
        }

        function closeCharacterCard(event) {
            if (!event || event.target.id === 'character-card-modal') {
                document.getElementById('character-card-modal').classList.remove('show');
            }
        }

        function centerOnSim(personId) {
            const pos = familyData.layout.positions[personId];
            if (!pos) return;

            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            state.translateX = rect.width / 2 - (pos.x + 90) * state.scale;
            state.translateY = rect.height / 2 - (pos.y + 65) * state.scale;
            updateTransform();

            // Highlight the node
            const node = document.getElementById(`node-${personId}`);
            if (node) {
                node.classList.add('highlighted');
                setTimeout(() => node.classList.remove('highlighted'), 3000);
            }

            closeCharacterCard();
        }

        // ============================================
        // SEARCH
        // ============================================
        function handleSearch() {
            const query = document.getElementById('search-input').value.toLowerCase().trim();
            const resultsDiv = document.getElementById('search-results');

            if (!query) {
                resultsDiv.style.display = 'none';
                return;
            }

            const matches = familyData.people.filter(p => 
                p.name.toLowerCase().includes(query)
            );

            if (matches.length === 0) {
                resultsDiv.innerHTML = '<div class="search-result-item">No results found</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            resultsDiv.innerHTML = matches.map(person => 
                `<div class="search-result-item" onclick="searchResultClick('${person.id}')">
                    ${person.name} (${person.lifestage || 'Unknown'})
                </div>`
            ).join('');
            resultsDiv.style.display = 'block';
        }

        function searchResultClick(personId) {
            centerOnSim(personId);
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').style.display = 'none';
        }

        // ============================================
        // EDIT MODE
        // ============================================
        function addNewSim() {
            if (!isAdmin) {
                alert('Only admins can add new Sims!');
                return;
            }
            state.currentEditingId = null;
            // Position new Sim in center of current view
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const centerX = (rect.width / 2 - state.translateX) / state.scale;
            const centerY = (rect.height / 2 - state.translateY) / state.scale;
            state.contextMenuPos = { x: centerX, y: centerY };
            openEditModal();
        }
        
        function toggleEditMode() {
            if (!isAdmin) {
                alert('Only admins can edit!');
                return;
            }
            state.editMode = !state.editMode;
            const btn = document.getElementById('edit-mode-btn');
            const container = document.getElementById('canvas-container');
            
            if (state.editMode) {
                btn.classList.add('active');
                btn.textContent = '‚úèÔ∏è Edit Mode (ON)';
                container.classList.add('edit-mode');
            } else {
                btn.classList.remove('active');
                btn.textContent = '‚úèÔ∏è Edit Mode';
                container.classList.remove('edit-mode');
            }
            
            render();
        }

        function handleContextMenu(e) {
            if (!state.editMode) return;
            e.preventDefault();
            
            const menu = document.getElementById('context-menu');
            const rect = document.getElementById('canvas').getBoundingClientRect();
            
            state.contextMenuPos.x = (e.clientX - rect.left) / state.scale;
            state.contextMenuPos.y = (e.clientY - rect.top) / state.scale;
            
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            menu.style.display = 'block';
        }

        function addSimFromContext() {
            document.getElementById('context-menu').style.display = 'none';
            state.currentEditingId = null;
            openEditModal();
        }

        function addRelationship() {
            document.getElementById('context-menu').style.display = 'none';
            alert('To add a relationship: Edit a Sim and select their partners or parents in the form.');
        }

        // ============================================
        // EDIT MODAL
        // ============================================
        function openEditModal() {
            uploadedPortraitData = null; // Reset upload data
            document.getElementById('portrait-filename').textContent = '';
            document.getElementById('portrait-preview').innerHTML = '';
            document.getElementById('edit-modal').classList.add('show');
            populateRelationshipSelectors();
            
            if (state.currentEditingId) {
                // Edit existing
                const person = familyData.people.find(p => p.id === state.currentEditingId);
                document.getElementById('edit-modal-title').textContent = 'Edit Sim';
                document.getElementById('edit-name').value = person.name;
                
                // Handle portrait
                if (person.portrait) {
                    if (person.portrait.startsWith('data:image/')) {
                        // It's an uploaded image
                        uploadedPortraitData = person.portrait;
                        document.getElementById('portrait-filename').textContent = 'Current image';
                        document.getElementById('portrait-preview').innerHTML = `<img src="${person.portrait}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid #ff69b4; box-shadow: 0 4px 15px rgba(255, 105, 180, 0.5);">`;
                        document.getElementById('edit-portrait').value = '';
                    } else {
                        // It's an emoji
                        document.getElementById('edit-portrait').value = person.portrait;
                    }
                } else {
                    document.getElementById('edit-portrait').value = '';
                }
                
                document.getElementById('edit-lifestage').value = person.lifestage;
                document.getElementById('edit-tags').value = person.tags.join(', ');
                document.getElementById('edit-traits').value = person.traits.join(', ');
                document.getElementById('edit-bio').value = person.bio || '';
                document.getElementById('edit-events').value = person.events.join('\n');
                
                // Select parents
                const parentRels = familyData.relationships.filter(r => 
                    r.type === 'parent' && r.to === state.currentEditingId
                );
                parentRels.forEach(rel => {
                    const item = document.querySelector(`#edit-parents [data-person-id="${rel.from}"]`);
                    if (item) item.classList.add('selected');
                });
                
                // Select partners
                const partnerRels = familyData.relationships.filter(r => 
                    r.type === 'partner' && (r.from === state.currentEditingId || r.to === state.currentEditingId)
                );
                partnerRels.forEach(rel => {
                    const partnerId = rel.from === state.currentEditingId ? rel.to : rel.from;
                    const item = document.querySelector(`#edit-partners [data-person-id="${partnerId}"]`);
                    if (item) item.classList.add('selected');
                });
                
                document.getElementById('delete-sim-btn').style.display = 'block';
            } else {
                // Add new
                document.getElementById('edit-modal-title').textContent = 'Add Sim';
                document.getElementById('edit-name').value = '';
                document.getElementById('edit-portrait').value = '';
                document.getElementById('edit-lifestage').value = 'Adult';
                document.getElementById('edit-tags').value = '';
                document.getElementById('edit-traits').value = '';
                document.getElementById('edit-bio').value = '';
                document.getElementById('edit-events').value = '';
                document.getElementById('delete-sim-btn').style.display = 'none';
            }
        }

        function populateRelationshipSelectors() {
            const parentsDiv = document.getElementById('edit-parents');
            const partnersDiv = document.getElementById('edit-partners');
            
            parentsDiv.innerHTML = '';
            partnersDiv.innerHTML = '';
            
            familyData.people.forEach(person => {
                if (person.id === state.currentEditingId) return;
                
                const parentItem = document.createElement('div');
                parentItem.className = 'multi-select-item';
                parentItem.textContent = person.name;
                parentItem.dataset.personId = person.id;
                parentItem.onclick = function() {
                    this.classList.toggle('selected');
                };
                parentsDiv.appendChild(parentItem);
                
                const partnerItem = document.createElement('div');
                partnerItem.className = 'multi-select-item';
                partnerItem.textContent = person.name;
                partnerItem.dataset.personId = person.id;
                partnerItem.onclick = function() {
                    this.classList.toggle('selected');
                };
                partnersDiv.appendChild(partnerItem);
            });
        }

        function editSim(personId) {
            if (!isAdmin) {
                alert('Only admins can edit Sims!');
                return;
            }
            state.currentEditingId = personId;
            openEditModal();
        }

        function saveEditedSim() {
            const name = document.getElementById('edit-name').value.trim();
            if (!name) {
                alert('Please enter a name!');
                return;
            }

            // Use uploaded image if available, otherwise use emoji field
            const portrait = uploadedPortraitData || document.getElementById('edit-portrait').value.trim() || null;
            const lifestage = document.getElementById('edit-lifestage').value;
            const tags = document.getElementById('edit-tags').value.split(',').map(t => t.trim()).filter(t => t);
            const traits = document.getElementById('edit-traits').value.split(',').map(t => t.trim()).filter(t => t);
            const bio = document.getElementById('edit-bio').value.trim();
            const events = document.getElementById('edit-events').value.split('\n').map(e => e.trim()).filter(e => e);

            const selectedParents = Array.from(document.querySelectorAll('#edit-parents .selected'))
                .map(el => el.dataset.personId);
            const selectedPartners = Array.from(document.querySelectorAll('#edit-partners .selected'))
                .map(el => el.dataset.personId);

            if (state.currentEditingId) {
                // Update existing
                const person = familyData.people.find(p => p.id === state.currentEditingId);
                person.name = name;
                person.portrait = portrait;
                person.lifestage = lifestage;
                person.tags = tags;
                person.traits = traits;
                person.bio = bio;
                person.events = events;

                // Update relationships
                // Remove old parent relationships
                familyData.relationships = familyData.relationships.filter(r => 
                    !(r.type === 'parent' && r.to === state.currentEditingId)
                );
                // Add new parent relationships
                selectedParents.forEach(parentId => {
                    familyData.relationships.push({
                        type: 'parent',
                        from: parentId,
                        to: state.currentEditingId,
                        kind: 'biological'
                    });
                });

                // Remove old partner relationships
                familyData.relationships = familyData.relationships.filter(r => 
                    !(r.type === 'partner' && (r.from === state.currentEditingId || r.to === state.currentEditingId))
                );
                // Add new partner relationships
                selectedPartners.forEach(partnerId => {
                    familyData.relationships.push({
                        type: 'partner',
                        from: state.currentEditingId,
                        to: partnerId,
                        status: 'dating'
                    });
                });
            } else {
                // Add new
                const newId = 'p' + Date.now();
                familyData.people.push({
                    id: newId,
                    name,
                    portrait,
                    lifestage,
                    tags,
                    traits,
                    bio,
                    events
                });

                // Set position (use context menu position or default)
                familyData.layout.positions[newId] = {
                    x: state.contextMenuPos.x - 90 || 0,
                    y: state.contextMenuPos.y - 65 || 0
                };

                // Add relationships
                selectedParents.forEach(parentId => {
                    familyData.relationships.push({
                        type: 'parent',
                        from: parentId,
                        to: newId,
                        kind: 'biological'
                    });
                });

                selectedPartners.forEach(partnerId => {
                    familyData.relationships.push({
                        type: 'partner',
                        from: newId,
                        to: partnerId,
                        status: 'dating'
                    });
                });
            }

            saveToStorage();
            render();
            closeEditModal();
        }

        function deleteCurrentSim() {
            if (!confirm('Are you sure you want to delete this Sim? This cannot be undone.')) {
                return;
            }

            familyData.people = familyData.people.filter(p => p.id !== state.currentEditingId);
            familyData.relationships = familyData.relationships.filter(r => 
                r.from !== state.currentEditingId && r.to !== state.currentEditingId
            );
            delete familyData.layout.positions[state.currentEditingId];

            saveToStorage();
            render();
            closeEditModal();
        }

        function closeEditModal(event) {
            if (!event || event.target.id === 'edit-modal') {
                document.getElementById('edit-modal').classList.remove('show');
                state.currentEditingId = null;
                uploadedPortraitData = null; // Clear the uploaded image data
                document.getElementById('portrait-filename').textContent = '';
                document.getElementById('portrait-preview').innerHTML = '';
            }
        }

        // ============================================
        // SAVE/LOAD
        // ============================================
        function saveToStorage() {
            // Admin users don't use localStorage - they download JSON instead
            // This prevents QuotaExceededError from large base64 images
            if (!isAdmin) {
                localStorage.setItem('familywreathData', JSON.stringify(familyData));
            }
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('familywreathData');
            if (saved) {
                try {
                    familyData = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load saved data:', e);
                }
            }
        }
        
        // ============================================
        // GITHUB FUNCTIONS
        // ============================================
        async function loadFamilyFromGitHub() {
            try {
                const response = await fetch(`https://raw.githubusercontent.com/${GITHUB_OWNER}/${DATA_REPO}/${BRANCH}/${FAMILY_FILE}`);
                
                if (!response.ok) {
                    console.log('No published family tree yet');
                    return false;
                }
                
                const data = await response.json();
                
                if (validateFamilyData(data)) {
                    familyData = data;
                    render();
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error loading family tree from GitHub:', error);
                return false;
            }
        }

        function downloadFamilyWreathJSON() {
            if (!isAdmin) {
                alert('Only admins can download!');
                return;
            }
            
            try {
                const content = JSON.stringify(familyData, null, 2);
                
                // Download the JSON file
                const blob = new Blob([content], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'family-wreath.json';
                a.click();
                URL.revokeObjectURL(url);
                
                // Save to localStorage too
                saveToStorage();
                
                alert('‚úÖ Downloaded family-wreath.json!\n\nüìã Next step: Upload this file to github.com/ravenjones2912/hortensiashausdata');
                
            } catch (error) {
                console.error('Error downloading:', error);
                alert('‚ùå Failed to download JSON file');
            }
        }

        function showExportImport() {
            const choice = prompt('Enter "export" to download JSON, or "import" to load JSON, or "reset" to clear localStorage:');
            
            if (choice === 'export') {
                exportJSON();
            } else if (choice === 'import') {
                importJSON();
            } else if (choice === 'reset') {
                if (confirm('This will delete all saved data and reload the default family. Continue?')) {
                    localStorage.removeItem('familywreathData');
                    location.reload();
                }
            }
        }

        function exportJSON() {
            const dataStr = JSON.stringify(familyData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'family-wreath.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (validateFamilyData(imported)) {
                            familyData = imported;
                            saveToStorage();
                            render();
                            alert('Import successful!');
                        } else {
                            alert('Invalid family data format.');
                        }
                    } catch (err) {
                        alert('Failed to parse JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function validateFamilyData(data) {
            return data && 
                   Array.isArray(data.people) && 
                   Array.isArray(data.relationships) && 
                   data.layout && 
                   typeof data.layout.positions === 'object';
        }

        // ============================================
        // MINIMAP
        // ============================================
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            // Pink background
            ctx.fillStyle = 'rgba(255, 192, 203, 0.3)';
            ctx.fillRect(0, 0, rect.width, rect.height);

            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            Object.values(familyData.layout.positions).forEach(pos => {
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x + 180);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y + 150);
            });

            const width = maxX - minX;
            const height = maxY - minY;
            const scale = Math.min(rect.width / width, rect.height / height) * 0.8;

            // Draw nodes in pink
            ctx.fillStyle = '#ff69b4';
            familyData.people.forEach(person => {
                const pos = familyData.layout.positions[person.id];
                const x = (pos.x - minX) * scale + (rect.width - width * scale) / 2;
                const y = (pos.y - minY) * scale + (rect.height - height * scale) / 2;
                ctx.fillRect(x, y, 180 * scale, 150 * scale);
            });

            // Draw viewport
            const container = document.getElementById('canvas-container');
            const containerRect = container.getBoundingClientRect();
            const viewport = document.getElementById('minimap-viewport');
            
            const vpX = (-state.translateX / state.scale - minX) * scale + (rect.width - width * scale) / 2;
            const vpY = (-state.translateY / state.scale - minY) * scale + (rect.height - height * scale) / 2;
            const vpW = (containerRect.width / state.scale) * scale;
            const vpH = (containerRect.height / state.scale) * scale;
            
            viewport.style.left = vpX + 'px';
            viewport.style.top = vpY + 'px';
            viewport.style.width = vpW + 'px';
            viewport.style.height = vpH + 'px';
        }
        
        // ============================================
        // FLOATING HEARTS
        // ============================================
        setInterval(() => {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = ['üíñ', '‚ú®', 'üíï', '‚≠ê', 'üíó', 'üå∏'][Math.floor(Math.random() * 6)];
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDuration = (Math.random() * 5 + 5) + 's';
            document.body.appendChild(heart);
            
            setTimeout(() => heart.remove(), 10000);
        }, 500);

        // ============================================
        // INITIALIZATION
        // ============================================
        window.addEventListener('load', init);

        // ============================================
        // DRAWING TOOLS - RULER, EMOJI, PEN
        // ============================================
        
        // Drawing state
        const drawingState = {
            penActive: false,
            eraseMode: false,
            penColor: '#ff1493',
            penWidth: 3,
            penType: 'solid',
            isDrawing: false,
            lastX: 0,
            lastY: 0,
            rulerRotation: 0,
            connectorDraft: null
        };

        // Drawing canvas setup
        const drawingCanvas = document.getElementById('drawing-canvas');
        const drawingCtx = drawingCanvas.getContext('2d');

        function resizeDrawingCanvas() {
            const container = document.getElementById('canvas-container');
            drawingCanvas.width = container.offsetWidth;
            drawingCanvas.height = container.offsetHeight;
        }
        resizeDrawingCanvas();
        window.addEventListener('resize', resizeDrawingCanvas);

        // Custom connector lines (stored as data so they move with sim cards)
        const customLinesSvg = document.getElementById('custom-lines-svg');

        function ensureCustomLinesArray() {
            if (!familyData.customLines) familyData.customLines = [];
        }

        function resizeCustomLinesSvg() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            customLinesSvg.style.left = rect.left + 'px';
            customLinesSvg.style.top = rect.top + 'px';
            customLinesSvg.style.width = rect.width + 'px';
            customLinesSvg.style.height = rect.height + 'px';
            customLinesSvg.setAttribute('width', rect.width);
            customLinesSvg.setAttribute('height', rect.height);
        }
        resizeCustomLinesSvg();
        window.addEventListener('resize', resizeCustomLinesSvg);

        function getNodeAnchorFromClientPoint(clientX, clientY, thresholdPx = 28) {
            // Returns { id, anchor:{u,v}, point:{x,y} } in CONTAINER-relative coords, or null
            const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
            const nodes = document.querySelectorAll('.sim-node');
            let best = null;

            nodes.forEach(node => {
                const r = node.getBoundingClientRect();

                // Closest point on rect to pointer
                const closestX = Math.max(r.left, Math.min(clientX, r.right));
                const closestY = Math.max(r.top, Math.min(clientY, r.bottom));

                const dx = clientX - closestX;
                const dy = clientY - closestY;
                const dist = Math.hypot(dx, dy);

                if (dist <= thresholdPx && (!best || dist < best.dist)) {
                    // Determine nearest EDGE point (top/bottom/left/right) for stable anchors
                    const dTop = Math.abs(closestY - r.top);
                    const dBottom = Math.abs(r.bottom - closestY);
                    const dLeft = Math.abs(closestX - r.left);
                    const dRight = Math.abs(r.right - closestX);

                    let edgeX = closestX;
                    let edgeY = closestY;

                    const minEdge = Math.min(dTop, dBottom, dLeft, dRight);
                    if (minEdge === dTop) edgeY = r.top;
                    else if (minEdge === dBottom) edgeY = r.bottom;
                    else if (minEdge === dLeft) edgeX = r.left;
                    else edgeX = r.right;

                    const u = (edgeX - r.left) / r.width;
                    const v = (edgeY - r.top) / r.height;

                    best = {
                        id: node.dataset.personId,
                        anchor: { u: Math.max(0, Math.min(1, u)), v: Math.max(0, Math.min(1, v)) },
                        point: { x: edgeX - containerRect.left, y: edgeY - containerRect.top },
                        dist
                    };
                }
            });

            return best ? { id: best.id, anchor: best.anchor, point: best.point } : null;
        }

        function getAnchorPointForPerson(personId, anchor) {
            // Returns container-relative coords
            const node = document.getElementById(`node-${personId}`);
            if (!node) return null;
            const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
            const r = node.getBoundingClientRect();
            return {
                x: (r.left - containerRect.left) + anchor.u * r.width,
                y: (r.top - containerRect.top) + anchor.v * r.height
            };
        }

        function renderCustomLines(previewLine = null) {
            ensureCustomLinesArray();
            resizeCustomLinesSvg();

            // Clear and redraw
            while (customLinesSvg.firstChild) customLinesSvg.removeChild(customLinesSvg.firstChild);

            const drawLine = (a, b, style, lineId = null) => {
                const el = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                el.setAttribute('x1', a.x);
                el.setAttribute('y1', a.y);
                el.setAttribute('x2', b.x);
                el.setAttribute('y2', b.y);
                el.setAttribute('stroke', style?.color || '#ff1493');
                el.setAttribute('stroke-width', style?.width || 3);
                el.setAttribute('stroke-linecap', 'round');

                if (style?.dash && Array.isArray(style.dash) && style.dash.length) {
                    el.setAttribute('stroke-dasharray', style.dash.join(','));
                }

                // If in remove mode, make the line clickable with a thicker invisible hitbox
                if (removeConnectorModeActive && lineId) {
                    // Create invisible wider line for easier clicking
                    const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hitbox.setAttribute('x1', a.x);
                    hitbox.setAttribute('y1', a.y);
                    hitbox.setAttribute('x2', b.x);
                    hitbox.setAttribute('y2', b.y);
                    hitbox.setAttribute('stroke', 'transparent');
                    hitbox.setAttribute('stroke-width', Math.max((style?.width || 3) * 3, 15)); // Make hitbox wider
                    hitbox.setAttribute('stroke-linecap', 'round');
                    hitbox.style.cursor = 'pointer';
                    hitbox.addEventListener('click', function(e) {
                        e.stopPropagation();
                        if (confirm('Delete this connector line?')) {
                            familyData.customLines = familyData.customLines.filter(l => l.id !== lineId);
                            saveToStorage();
                            renderCustomLines();
                        }
                    });
                    
                    // Add hover effect
                    hitbox.addEventListener('mouseenter', function() {
                        el.setAttribute('stroke', '#ff0000');
                        el.setAttribute('stroke-width', (style?.width || 3) * 1.5);
                    });
                    hitbox.addEventListener('mouseleave', function() {
                        el.setAttribute('stroke', style?.color || '#ff1493');
                        el.setAttribute('stroke-width', style?.width || 3);
                    });
                    
                    customLinesSvg.appendChild(hitbox);
                }

                customLinesSvg.appendChild(el);
            };

            familyData.customLines.forEach(line => {
                const a = getAnchorPointForPerson(line.fromId, line.fromAnchor);
                const b = getAnchorPointForPerson(line.toId, line.toAnchor);
                if (!a || !b) return;
                drawLine(a, b, line.style, line.id);
            });

            if (previewLine) {
                drawLine(previewLine.a, previewLine.b, previewLine.style || { color: drawingState.penColor, width: drawingState.penWidth });
            }
        }

        // ========== RULER TOOL (PROJECTION-BASED) ==========
        let rulerDragging = false;
        let rulerOffsetX = 0;
        let rulerOffsetY = 0;
        let rulerCenterX = 0; // Ruler center in page coordinates
        let rulerCenterY = 0;

        function toggleRuler() {
            const ruler = document.getElementById('ruler');
            if (ruler.style.display === 'none') {
                ruler.style.display = 'block';
                // Position at center of viewport
                const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
                rulerCenterX = containerRect.left + containerRect.width / 2;
                rulerCenterY = containerRect.top + containerRect.height / 2;
                ruler.style.left = rulerCenterX + 'px';
                ruler.style.top = rulerCenterY + 'px';
                ruler.style.transform = 'translate(-50%, -50%)';
                drawingState.rulerRotation = 0;
                updateRulerState();
            } else {
                ruler.style.display = 'none';
            }
        }

        function rotateRuler() {
            drawingState.rulerRotation = (drawingState.rulerRotation + 15) % 360;
            const ruler = document.getElementById('ruler');
            ruler.style.transform = `translate(-50%, -50%) rotate(${drawingState.rulerRotation}deg)`;
            updateRulerState();
        }

        function closeRuler() {
            document.getElementById('ruler').style.display = 'none';
        }

        function updateRulerState() {
            // Store ruler center and angle for projection calculations
            const ruler = document.getElementById('ruler');
            const rect = ruler.getBoundingClientRect();
            rulerCenterX = rect.left + rect.width / 2;
            rulerCenterY = rect.top + rect.height / 2;
        }

        // Ruler dragging - using pointer events for better touch support
        const rulerBody = document.getElementById('ruler-body');
        rulerBody.addEventListener('pointerdown', function(e) {
            if (e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                rulerDragging = true;
                const ruler = document.getElementById('ruler');
                const rect = ruler.getBoundingClientRect();
                rulerOffsetX = e.clientX - (rect.left + rect.width / 2);
                rulerOffsetY = e.clientY - (rect.top + rect.height / 2);
                ruler.setPointerCapture(e.pointerId);
            }
        });

        document.addEventListener('pointermove', function(e) {
            if (rulerDragging) {
                const ruler = document.getElementById('ruler');
                rulerCenterX = e.clientX - rulerOffsetX;
                rulerCenterY = e.clientY - rulerOffsetY;
                ruler.style.left = rulerCenterX + 'px';
                ruler.style.top = rulerCenterY + 'px';
                ruler.style.transform = `translate(-50%, -50%) rotate(${drawingState.rulerRotation}deg)`;
            }
        });

        document.addEventListener('pointerup', function() {
            rulerDragging = false;
        });

        // ========== PROJECTION MATH ==========
        function projectPointOntoRuler(x, y) {
            // Project a screen-space point onto the TOP edge of the ruler (Snipping Tool style)
            // Uses rulerCenterX/Y (screen coords) and drawingState.rulerRotation (deg)

            // Convert rotation to radians
            const angleRad = (drawingState.rulerRotation * Math.PI) / 180;

            // Direction vector along the ruler
            const dirX = Math.cos(angleRad);
            const dirY = Math.sin(angleRad);

            // "Up" normal (perpendicular)
            const nX = -dirY;
            const nY = dirX;

            // Offset the projection line from the ruler center to the TOP edge
            const rulerRect = document.getElementById('ruler').getBoundingClientRect();
            const edgeOffset = -rulerRect.height / 2; // flip sign if you want bottom edge instead
            const ax = rulerCenterX + nX * edgeOffset;
            const ay = rulerCenterY + nY * edgeOffset;

            // Project (x,y) onto the infinite line through (ax,ay) in direction (dirX,dirY)
            const apX = x - ax;
            const apY = y - ay;
            const t = apX * dirX + apY * dirY;

            return { x: ax + t * dirX, y: ay + t * dirY };
        }

        function isRulerActive() {
            return document.getElementById('ruler').style.display !== 'none';
        }

        // ========== EMOJI TOOL ==========
        function toggleEmojiPicker() {
            const picker = document.getElementById('emoji-picker');
            picker.style.display = picker.style.display === 'none' ? 'block' : 'none';
        }

        function closeEmojiPicker() {
            document.getElementById('emoji-picker').style.display = 'none';
        }

        function addEmoji(emoji) {
            // Create draggable emoji element
            const emojiEl = document.createElement('div');
            emojiEl.textContent = emoji;
            emojiEl.className = 'draggable-emoji';
            emojiEl.style.cssText = `
                position: absolute;
                font-size: 48px;
                cursor: move;
                z-index: 50;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                user-select: none;
            `;
            
            // Make it draggable
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;
            
            const onMouseDown = function(e) {
                isDragging = true;
                const rect = emojiEl.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                emojiEl.style.zIndex = 100;
                e.preventDefault();
            };

            const onMouseMove = function(e) {
                if (isDragging) {
                    emojiEl.style.left = (e.clientX - offsetX) + 'px';
                    emojiEl.style.top = (e.clientY - offsetY) + 'px';
                    emojiEl.style.transform = 'none';
                }
            };

            const onMouseUp = function() {
                if (isDragging) {
                    isDragging = false;
                    emojiEl.style.zIndex = 50;
                }
            };
            
            emojiEl.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);

            // Double-click to delete
            emojiEl.addEventListener('dblclick', function() {
                if (confirm('Delete this emoji?')) {
                    emojiEl.remove();
                }
            });

            document.getElementById('canvas-container').appendChild(emojiEl);
            closeEmojiPicker();
        }

        // ========== PEN TOOL ==========
        function togglePenTool() {
            const panel = document.getElementById('pen-tool-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            
            // Make panel draggable
            if (!panel.hasAttribute('data-draggable-init')) {
                let isDragging = false;
                let offsetX = 0;
                let offsetY = 0;
                
                panel.addEventListener('mousedown', function(e) {
                    // Only drag if clicking the panel background, not buttons/inputs
                    if (e.target === panel || e.target.tagName === 'H3' || e.target.tagName === 'LABEL') {
                        isDragging = true;
                        offsetX = e.clientX - panel.offsetLeft;
                        offsetY = e.clientY - panel.offsetTop;
                    }
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (isDragging) {
                        panel.style.left = (e.clientX - offsetX) + 'px';
                        panel.style.top = (e.clientY - offsetY) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', function() {
                    isDragging = false;
                });
                
                panel.setAttribute('data-draggable-init', 'true');
            }
        }

        function closePenTool() {
            document.getElementById('pen-tool-panel').style.display = 'none';
            stopDrawing();
        }

        function updatePenType() {
            drawingState.penType = document.getElementById('pen-type').value;
        }

        function updatePenWidth() {
            drawingState.penWidth = document.getElementById('pen-width').value;
            document.getElementById('pen-width-display').textContent = drawingState.penWidth + 'px';
        }

        function setPenColor(color) {
            drawingState.penColor = color;
        }

        function getDashArrayForPenType() {
            if (drawingState.penType === 'dashed') return [10, 5];
            if (drawingState.penType === 'dotted') return [2, 3];
            return [];
        }


        function startDrawing() {
            drawingState.penActive = true;
            drawingState.eraseMode = false;
            drawingCanvas.style.pointerEvents = 'auto';
            drawingCanvas.style.cursor = 'crosshair';
            document.getElementById('draw-btn').style.background = 'linear-gradient(135deg, #228b22, #006400)';
            document.getElementById('erase-btn').style.background = 'linear-gradient(135deg, #ffa500, #ff8c00)';
        }

        function startErasing() {
            drawingState.penActive = true;
            drawingState.eraseMode = true;
            drawingCanvas.style.pointerEvents = 'auto';
            drawingCanvas.style.cursor = 'grab';
            document.getElementById('draw-btn').style.background = 'linear-gradient(135deg, #32cd32, #228b22)';
            document.getElementById('erase-btn').style.background = 'linear-gradient(135deg, #ff8c00, #ff6600)';
        }

        function stopDrawing() {
            drawingState.penActive = false;
            drawingState.eraseMode = false;
            drawingCanvas.style.pointerEvents = 'none';
            drawingCanvas.style.cursor = 'default';
            drawingState.isDrawing = false;
            document.getElementById('draw-btn').style.background = 'linear-gradient(135deg, #32cd32, #228b22)';
            document.getElementById('erase-btn').style.background = 'linear-gradient(135deg, #ffa500, #ff8c00)';
            drawingState.removeConnectorMode = false;
            document.getElementById('remove-connector-btn').style.background = 'linear-gradient(135deg, #dc143c, #8b0000)';
            const svg = document.getElementById('custom-lines-svg');
            svg.style.pointerEvents = 'none';
        }

        // State for remove connector mode
        let removeConnectorModeActive = false;

        function toggleRemoveConnectorMode() {
            removeConnectorModeActive = !removeConnectorModeActive;
            const btn = document.getElementById('remove-connector-btn');
            const svg = document.getElementById('custom-lines-svg');
            
            if (removeConnectorModeActive) {
                // Stop any other drawing modes
                stopDrawing();
                
                // Activate remove mode
                btn.style.background = 'linear-gradient(135deg, #8b0000, #dc143c)';
                btn.style.transform = 'scale(1.05)';
                svg.style.pointerEvents = 'auto';
                svg.style.cursor = 'pointer';
                
                // Re-render lines with clickable option
                renderCustomLines();
            } else {
                // Deactivate remove mode
                btn.style.background = 'linear-gradient(135deg, #dc143c, #8b0000)';
                btn.style.transform = 'scale(1)';
                svg.style.pointerEvents = 'none';
                svg.style.cursor = 'default';
                
                // Re-render lines without clickable option
                renderCustomLines();
            }
        }

        function clearAllDrawings() {
            if (confirm('Clear all drawings?')) {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }
        }

        // Drawing event listeners with ruler projection support
        drawingCanvas.addEventListener('pointerdown', function(e) {
            if (!drawingState.penActive) return;

            // If ruler is active (and we're drawing, not erasing), allow "connector line" creation:
            // Start/end snap to sim cards, and the line will move with them.
            if (isRulerActive() && !drawingState.eraseMode) {
                ensureCustomLinesArray();

                const projectedScreen = projectPointOntoRuler(e.clientX, e.clientY);
                const startHit = getNodeAnchorFromClientPoint(projectedScreen.x, projectedScreen.y);

                if (startHit) {
                    drawingState.connectorDraft = {
                        fromId: startHit.id,
                        fromAnchor: startHit.anchor
                    };

                    // Show an initial preview (zero-length)
                    const a = getAnchorPointForPerson(startHit.id, startHit.anchor);
                    renderCustomLines({ a, b: a, style: { color: drawingState.penColor, width: drawingState.penWidth, dash: getDashArrayForPenType() } });

                    drawingCanvas.setPointerCapture(e.pointerId);
                    return; // do not start freehand canvas drawing
                }
            }

            // Otherwise: normal freehand drawing (optionally projected onto ruler)
            drawingState.isDrawing = true;

            const rect = drawingCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;

            if (isRulerActive() && !drawingState.eraseMode) {
                const projected = projectPointOntoRuler(e.clientX, e.clientY);
                x = projected.x - rect.left;
                y = projected.y - rect.top;
            }

            drawingState.lastX = x;
            drawingState.lastY = y;
        });

        drawingCanvas.addEventListener('pointermove', function(e) {
            if (!drawingState.penActive) return;

            // Connector preview mode (ruler + snapped start)
            if (drawingState.connectorDraft) {
                const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
                const projectedScreen = projectPointOntoRuler(e.clientX, e.clientY);

                // If we're close to a node, snap the endpoint to it
                const endHit = getNodeAnchorFromClientPoint(projectedScreen.x, projectedScreen.y);

                const a = getAnchorPointForPerson(drawingState.connectorDraft.fromId, drawingState.connectorDraft.fromAnchor);
                const b = endHit
                    ? endHit.point
                    : { x: projectedScreen.x - containerRect.left, y: projectedScreen.y - containerRect.top };

                renderCustomLines({ a, b, style: { color: drawingState.penColor, width: drawingState.penWidth, dash: getDashArrayForPenType() } });
                return;
            }

            // Freehand draw / erase mode
            if (!drawingState.isDrawing) return;

            const rect = drawingCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;

            if (isRulerActive() && !drawingState.eraseMode) {
                const projected = projectPointOntoRuler(e.clientX, e.clientY);
                x = projected.x - rect.left;
                y = projected.y - rect.top;
            }

            drawingCtx.beginPath();
            drawingCtx.moveTo(drawingState.lastX, drawingState.lastY);
            drawingCtx.lineTo(x, y);

            if (drawingState.eraseMode) {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.strokeStyle = 'rgba(0,0,0,1)';
                drawingCtx.lineWidth = drawingState.penWidth * 3;
                drawingCtx.setLineDash([]);
            } else {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = drawingState.penColor;
                drawingCtx.lineWidth = drawingState.penWidth;
                drawingCtx.setLineDash(getDashArrayForPenType());
            }

            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.stroke();

            drawingState.lastX = x;
            drawingState.lastY = y;
        });

        drawingCanvas.addEventListener('pointerup', function(e) {
            // Finish connector line if we were drafting one
            if (drawingState.connectorDraft) {
                const projectedScreen = projectPointOntoRuler(e.clientX, e.clientY);
                const endHit = getNodeAnchorFromClientPoint(projectedScreen.x, projectedScreen.y);

                if (endHit && endHit.id !== drawingState.connectorDraft.fromId) {
                    familyData.customLines.push({
                        id: 'cl-' + Date.now() + '-' + Math.floor(Math.random() * 10000),
                        fromId: drawingState.connectorDraft.fromId,
                        toId: endHit.id,
                        fromAnchor: drawingState.connectorDraft.fromAnchor,
                        toAnchor: endHit.anchor,
                        style: {
                            color: drawingState.penColor,
                            width: Number(drawingState.penWidth),
                            dash: getDashArrayForPenType()
                        }
                    });
                    saveToStorage();
                }

                drawingState.connectorDraft = null;
                renderCustomLines();
                drawingCanvas.releasePointerCapture?.(e.pointerId);
                return;
            }

            drawingState.isDrawing = false;
        });

        drawingCanvas.addEventListener('pointerleave', function() {
            drawingState.isDrawing = false;

            if (drawingState.connectorDraft) {
                drawingState.connectorDraft = null;
                renderCustomLines();
            }
        });
    </script>
</body>
</html>

<!--
ACCEPTANCE CHECKLIST:
[‚úì] Pan works - Click and drag empty space to move around the canvas
[‚úì] Zoom works - Mouse wheel/trackpad zooms toward cursor with limits (0.3x - 2.5x)
[‚úì] Click opens character card - Clicking a Sim shows their full details in a modal
[‚úì] Search centers correctly - Type to search, click result centers and highlights the Sim
[‚úì] Drag rearrange updates lines - In Edit Mode, drag Sims to reposition; relationship lines update in real-time
[‚úì] localStorage save/load works - All changes persist automatically in browser storage
[‚úì] JSON import/export works - Export to download JSON file, Import to upload and restore data

BONUS FEATURES IMPLEMENTED:
[‚úì] Edit mode toggle - Right-click/long-press disabled in favor of double-click and dedicated UI
[‚úì] Add/Edit/Delete Sims via modal forms
[‚úì] Validation prevents impossible relationships (handled through UI constraints)
[‚úì] Mobile-friendly with touch support and pinch-to-zoom
[‚úì] Minimap showing viewport position
[‚úì] "Fit to Screen" and "Reset View" buttons
[‚úì] Relationship status indicators (married, divorced, dating)
[‚úì] Visual distinction for adoptive relationships (dashed lines)
[‚úì] Occult tag styling (vampire, spellcaster, ghost, mermaid, alien)
[‚úì] Character card with clickable relationship links
[‚úì] Zoom controls with on-screen buttons
[‚úì] 13-person seed family with multi-generation data, divorce, remarriage, adoption, and occult Sims
-->
